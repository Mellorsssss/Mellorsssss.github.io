<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一周小结</title>
    <link href="/2022/01/18/20220118/"/>
    <url>/2022/01/18/20220118/</url>
    
    <content type="html"><![CDATA[<p>上一周完成了6.824 lab3, 智齿发炎所以此外基本没做啥.</p><p>这周计划是看klee,开始做毕设.空闲时间读leveldb,开始做lab4(或许先继续优化一下lab3?现在感觉不是特别快).</p>]]></content>
    
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一周小结</title>
    <link href="/2022/01/10/20220110/"/>
    <url>/2022/01/10/20220110/</url>
    
    <content type="html"><![CDATA[<p>主要读了<em>Database internal</em>的LSM Tree相关部分,顺便完成了对6.824 lab2的优化.自己最近感兴趣的点主要就是存储以及分布式系统,这周准备带着看一下leveldb中LSM Tree相关实现,完成6.824 的lab 3.</p><h3 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM Tree"></a>LSM Tree</h3><p>LSM Tree主要的优点在于写入速度很快(SSD sequential write速度和mem的random write相当),缺点则是读和空间放大比较严重.</p><p>自己目前还没有看过任何LSM Tree的实现,只通过<em>Database Internal</em>了解过一点简单的LSM原理,包括但不限于以下知识点:</p><ul><li>LSM Tree是什么(memtable, memtable)?为什么用它?</li><li>LSM Tree怎么做read/write/delete?</li><li>…怎么优化冗余的键值对?</li><li>…怎么优化读放大?</li></ul><h3 id="raft优化"><a href="#raft优化" class="headerlink" title="raft优化"></a>raft优化</h3><p>由于是二刷6.824,这一次完成lab2一共大概花了4天时间(通过所有测试),但是优化代码花了一周时间.</p><p>虽说是优化,其实只是面向测试样例的一些简单调优,并没有对raft算法本身做巨大改动.主要的测试指标为:rpc数量以及测试完成时间.</p><p>完成优化之后lab2共计耗时5分30秒左右(100次运行平均),此处给出2B以及2C的测试数据:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Test </span>(2A): initial election ...<br>  ... Passed --   3.1  3   60   15080    0<br><span class="hljs-keyword">Test </span>(2A): election after network failure ...<br>  ... Passed --   5.0  3  142   26268    0<br><span class="hljs-keyword">Test </span>(2A): multiple elections ...<br>  ... Passed --   6.4  7  577  105547    0<br><span class="hljs-keyword">Test </span>(2B): basic agreement ...<br>  ... Passed --   0.3  3   16    4107    3<br><span class="hljs-keyword">Test </span>(2B): RPC byte count ...<br>  ... Passed --   0.5  3   48  153102   11<br><span class="hljs-keyword">Test </span>(2B): agreement despite follower disconnection ...<br>  ... Passed --   2.9  3   81   20270    7<br><span class="hljs-keyword">Test </span>(2B): no agreement if too many followers disconnect ...<br>  ... Passed --   3.3  5  191   37753    3<br><span class="hljs-keyword">Test </span>(2B): concurrent Start()s ...<br>  ... Passed --   0.6  3   20    5614    6<br><span class="hljs-keyword">Test </span>(2B): rejoin of partitioned leader ...<br>  ... Passed --   4.5  3  159   33320    4<br><span class="hljs-keyword">Test </span>(2B): leader backs up quickly over incorrect follower logs ...<br>  ... Passed --   9.3  5 1354  946435  102<br><span class="hljs-keyword">Test </span>(2B): RPC counts aren&#x27;t too high ...<br>  ... Passed --   2.0  3   46   13453   12<br><span class="hljs-keyword">Test </span>(2C): basic persistence ...<br>  ... Passed --   4.0  3  103   23403    6<br><span class="hljs-keyword">Test </span>(2C): more persistence ...<br>  ... Passed --  13.6  5  835  176284   16<br><span class="hljs-keyword">Test </span>(2C): partitioned leader and one follower crash, leader restarts ...<br>  ... Passed --   1.1  3   35    8487    4<br><span class="hljs-keyword">Test </span>(2C): Figure 8 ...<br>  ... Passed --  34.7  5 1014  184489   32<br><span class="hljs-keyword">Test </span>(2C): unreliable agreement ...<br>  ... Passed --   2.4  5  978  311040  246<br><span class="hljs-keyword">Test </span>(2C): Figure 8 (unreliable) ...<br>  ... Passed --  36.7  5 5282 11695881  168<br><span class="hljs-keyword">Test </span>(2C): churn ...<br>  ... Passed --  16.4  5 4607 2857762  767<br><span class="hljs-keyword">Test </span>(2C): unreliable churn ...<br>  ... Passed --  16.1  5 2179  874603  374<br><span class="hljs-keyword">Test </span>(2D): snapshots basic ...<br>  ... Passed --   1.8  3  173   69754  251<br><span class="hljs-keyword">Test </span>(2D): install snapshots (disconnect) ...<br>  ... Passed --  43.4  3 1583  427709  388<br><span class="hljs-keyword">Test </span>(2D): install snapshots (disconnect+unreliable) ...<br>  ... Passed --  45.7  3 1819  455134  344<br><span class="hljs-keyword">Test </span>(2D): install snapshots (crash) ...<br>  ... Passed --  34.5  3  889  272795  377<br><span class="hljs-keyword">Test </span>(2D): install snapshots (unreliable+crash) ...<br>  ... Passed --  37.3  3 1041  294722  355<br>PASS<br>ok      6.824/raft      325.832s<br></code></pre></td></tr></table></figure><p>我采取了如下的一些手段实现上述两个指标的优化:</p><ul><li>“批”处理start请求.leader维护一个$nextInd$至$nextInd+x$的窗口,只有在这个窗口内的start请求才会被立即发送.我在实验过程中注意到,经常会出现同时start若干个请求,我一开始的实现是对于每一个start请求都立刻进行一轮AE,但实际上没有必要.好处是,如果出现瞬时较多的start请求,会保证一个窗口内的请求立刻被处理(没有真正的批处理带来的一定时延),而剩余的请求则做batch处理(这些请求本身就已经不会被立刻处理了,直接作batch),保证了不会同时产生太多的AE rpc;坏处是对于窗口之外的请求会存在比较高昂的失败代价.</li><li>heartbeat优化.实际上没有必要专门使用empty AE rpc去做heartbeat,如果在heartbeat timeout结束之前已经发送了AE请求,实际上可以不发送heartbeat.这样做可以减轻网络带宽压力.</li><li>使用Cond减少for check带来的开销.对于appCh的提交我使用了sync.Cond,只有在commitInd可能发生变化的时候才检查是否需要提交到appCh上.</li></ul><p>实验整体感觉不难,主要的坑点在于多线程无法调试(实际生产环境中就是分布式集群了,但是可以在一个机器上调试),遇到的主要的问题有:</p><ul><li>2D实验中的Snapshot和CondInstallSnapshot产生的隐蔽的死锁</li><li>rpc上下文切换后带来的隐蔽错误(处理rpc回复时的rf的各个信息都已经被更新过了,可能有问题!)</li><li>…</li></ul><p>对了,还看了 <em>Don’t look up</em>,美国老完蛋了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>weekly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【小坑】VSC上配置go开发环境</title>
    <link href="/2021/10/04/go-config-vsc/"/>
    <url>/2021/10/04/go-config-vsc/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前写的6.824是2020版本的，中间搁置之后发现很难读懂自己之前写的raft部分了，所以干脆重开一下。之前是在虚拟机里面使用goland进行开发，体验不是十分流畅，改为使用VSC remote explore模式。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>ctrl+shift+p</code>后<code>go install tools</code>无法正常安装，原因是安装的源被墙了，网上有解决方案，如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GO111MODULE=<span class="hljs-keyword">on</span><br><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GOPROXY=http<span class="hljs-variable">s:</span>//goproxy.<span class="hljs-keyword">cn</span>,direct<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>285场周赛总结</title>
    <link href="/2021/08/15/leetcode-210815/"/>
    <url>/2021/08/15/leetcode-210815/</url>
    
    <content type="html"><![CDATA[<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>判断一个字符串数组中有多少个字符串是特定字符串的子串，使用<code>string::find</code>即可，判断返回值是否是<code>string::npos</code>。</p><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>构造一个数组，使得数组中不存在任何相邻的三个数字<code>a, b, c</code>，满足<code>a + c = 2b</code>。</p><p>想要该条件不满足，实际上也就是让<code>b - a = c - b</code>对任何三个相邻数字不满足，显然，我们可以进行如下的一个简单构造：</p><p>将前一半数字放置在偶数位置上，后一半数字放置在基数位置上。</p><p>上述构造保证了差值是正负正负……分布的。</p><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>本场比赛花了最长时间的题目，事后复盘，主要存在两个问题：</p><ol><li>大概猜到了规律，但是没有大胆验证，而是尝试通过比较一般的方式思考，浪费了比较多的时间；</li><li>对于右移操作的不熟悉，中间多次RE；</li></ol><p>前者是算法思路，后者是对c的运算符运算底层害不够熟悉。</p><p>本题给定一个<code>p</code>对应的幂集（去掉0），并且可以任意调换两个数字中的各个位，问怎样使得最后的乘积最小。</p><p>显然，对于任何两个数字而言，最好的策略就是让其中一个数字尽量小，我猜测的策略是通过逐个配对，将一系列数字变为1。</p><p>坑点在于这个运算不可以使用左移，只能通过快速幂；ull的右移也应该通过除法做。</p><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p>说是hard，其实思路很简单，有一定编码难度，但是一直RE（原因是它给的Cells数组从中的索引从1开始）。</p><p>显然可以直接二分，判定使用bfs即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【x日x题】PAT 1003 dijkstra模板</title>
    <link href="/2021/07/25/tj210725/"/>
    <url>/2021/07/25/tj210725/</url>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个无向图，每一个点有点权，求最短路条数以及最短路上可能的最大边权。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>除了计算最短路之外，需要计算出最短路条数以及最短路中可能的最大点权，这两个问题都可以通过动态规划完成。这两个问题实际上应该在dijkstra的松弛操作中完成，因为发生松弛时，说明产生了新的最短路。</p><p>对于前者，很容易想到为每一个点维护一个状态<code>num[]</code>，即到该点的最短路条数，那么$num[i] = \sum_{v是i的邻居，并且在和i在同一条最短路上}num[i]$。</p><p>对于后者，为每一个点定义一个最大点权<code>p[]</code>，更新方程类似，此处留给读者思考吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dijkstra</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081 traps &amp; lazy allocation实验记录</title>
    <link href="/2021/07/24/xv6-lab45/"/>
    <url>/2021/07/24/xv6-lab45/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文仅作为个人学习的记录，如果你还没有完成相应的实验，不建议阅读本文。</p><h3 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h3><p>本实验分为三个部分，第一个部分是回答关于riscv的一些问题，按下不表；第二个部分是实现一个简单的<code>backtrace</code>，最后一个部分是实验的主体——实现一个定时器事件系统调用。</p><h4 id="backtrace实现"><a href="#backtrace实现" class="headerlink" title="backtrace实现"></a>backtrace实现</h4><p>了解riscv的ABI中关于stack frame的部分即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210724172113.png" alt="image-20210724172106610"></p><p>fp中保存的是当前的stack frame的基址，fp-8位置保存的是返回地址，fp-16部分保存的是上一个fp。</p><p>判断当前fp是否是<strong>栈底部</strong>（xv6中给栈一共分配了一页的空间），如果不是，那么递归输出return address即可。</p><h4 id="Alarm实现"><a href="#Alarm实现" class="headerlink" title="Alarm实现"></a>Alarm实现</h4><p>Alarm分为两个部分——注册回调、返回。</p><h5 id="注册回调"><a href="#注册回调" class="headerlink" title="注册回调"></a>注册回调</h5><p>注册回调部分通过<code>sigalarm</code>实现，其传入tick period以及handler。其中tick period指明了过多少个tick调用一次回调函数，handler是回调函数的地址。</p><p>显然，我们需要在内核态保存关于当前tick的信息（实际上内核维护了一个cpu tick的信息，应该也可以使用这个值进行做差），同时记录handler的地址。每发生一次timer interrupt，tick++，当当前进程的tick period达到时，修改epc使得进程通过usertrapret()返回到handler中。</p><h5 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h5><p>当handler执行完成之后， 如果不做特殊处理，handler可能返回到一个莫名其妙的地方。我们希望handler执行完成之后，跳转回timer interrupt发生的现场继续执行——换而言之，我们需要在切换到handler的那一次usertrapret中记录当前的trapframe,通过调用sigreturn，恢复trapframe，从而跳转到timer interrupt的现场。</p><blockquote><p>注意点</p><ol><li>handler在执行过程中不可以再次被打断（试想再次被打断，trapframe会被冲掉！也就回不到之前的现场了。当然可以用一个栈保存现场……）；</li></ol></blockquote><h3 id="Lazy-Page-Allocation"><a href="#Lazy-Page-Allocation" class="headerlink" title="Lazy Page Allocation"></a>Lazy Page Allocation</h3><p><del>其实我觉得xv6这个实验，你只要懂英文，照着manual做都能做满分</del></p><p>简单说来，需要在xv6 kernel上修改的核心内容：</p><ul><li>sbrk系统调用：不再分配page，如果参数为负，需要减少page</li><li>usertrap：添加对page fault的处理</li><li>page fault: 判断合法性（是否是invalid page）后分配page</li><li>内核中涉及address的地方：判断地址合法性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>实验记录</tag>
      
      <tag>6.s0801</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6源码阅读与分析-trap部分【未完成】</title>
    <link href="/2021/07/23/xv6-source-trap/"/>
    <url>/2021/07/23/xv6-source-trap/</url>
    
    <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>RSICV指令集基本了解。</p><p>了解trap过程中会涉及的几个寄存器（stvec, scause, sscratch, sepc等）</p><h3 id="trampoline-s"><a href="#trampoline-s" class="headerlink" title="trampoline.s"></a>trampoline.s</h3><p>trampoline顾名思义，实际上就是一个跳板页，其在user space和kernel space<strong>映射在同一个虚拟地址上</strong>，这么做是为了在切换页表之后，可以正常执行代码。</p><p>包含两个部分的代码：</p><ul><li>uservec。使用汇编编写，用于从用户态切换到内核态并且执行usertrap()函数。代码注释非常详尽，主要分为三步：保存现场；切换到内核态；跳转到usertrap()执行。首先交换sscratch和a0寄存器的值，此时的a0寄存器存放的就是<strong>trapframe的基址</strong>,，接下来将所有的寄存器的值存入trapframe中（后续userret需要恢复）；然后通过trapframe，恢复sp、tp等寄存器为内核态的值，最重要的是设置satp（相当于x86-64中的cr3，存放页表基地址），并切换到内核页表；最后跳转到usertrap，函数地址也是存放在trapframe中的。</li><li>userret。与uservec相对应，从usertrapret()函数中调用，有两个参数，分别是TRAPFRAME地址以及用户态的satp，用于返回user space。首先，切换页表（trapframe是在user space 中映射的）；接下来，从trapframe中恢复用户态上下文，这里有一个细节需要注意：由于a0已经存放了TRAPFRAME，所以需要先使用sscratch保存a0，最后再交换回来（a1尽管保存了Satp，但是一开始就已经使用过了，所以可以直接overwrite）。最后，由于usertrapret()中已经设置好了epc，直接使用sret指令返回即可。</li></ul><h3 id="trap-c"><a href="#trap-c" class="headerlink" title="trap.c"></a>trap.c</h3><p>通过trampoline.s的分析，我们知道trampoline.s中的两个函数实际上就是入口和出口，具体执行的代码位于trap.c中，主要是usertrap(),kerneltrap(),usertrapret()三个函数。</p><ul><li><p>usertrap()只能通过用户态陷入内核态的时候调用。首先内核会检查是否从用户态陷入，然后设置stvec为kernelvec()（因为如果现在再次发生了中断，那么不需要再切换页表了，只需要像普通的函数调用一样保存现场）；接着根据trap的类型，判断应该如何处理：系统调用、设备中断、异常情况（直接kill）；最后，如果没有被kill,那么调用usertrapret()返回用户态。</p><blockquote><p><code>intr_on</code>的调用时机</p><p>源代码中在确认了sstatus等寄存之后才开中断，是为了防止中途出现其他trap破坏了这些寄存器。</p></blockquote></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>源码阅读</tag>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何Debug XV6</title>
    <link href="/2021/07/23/xv6-debug/"/>
    <url>/2021/07/23/xv6-debug/</url>
    
    <content type="html"><![CDATA[<p>由于6.s081使用的Xv6是基于rsicv架构的，而我使用的虚拟机为x86-64架构，故而需要使用交叉编译的技术。</p><p>幸运的是，6.s081课程平台上已经提供了交叉编译需要的工具，例如gdb,gcc等；调试xv6，gdb是必不可少的。</p><p>具体而言，我们在一个终端中使用单核启动xv6:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  xv6-labs-2020 git:(traps) ✗ make CPUS=1 qemu-gdb<br>*** Now run &#x27;gdb&#x27; in another window.<br>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26001<br></code></pre></td></tr></table></figure><p>在另一个终端中，我们运行gdb即可（注意，是运行rsicv对应的gdb！）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  xv6-labs-2020 git:(traps) ✗ riscv64-unknown-elf-gdb          <br>GNU gdb (GDB) 10.1<br>Copyright (C) 2020 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type &quot;show copying&quot; and &quot;show warranty&quot; for details.<br>This GDB was configured as &quot;--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf&quot;.<br>Type &quot;show configuration&quot; for configuration details.<br>For bug reporting instructions, please see:<br>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For help, type &quot;help&quot;.<br>Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.<br>warning: File &quot;/home/cs18/myproj/6.828/xv6-labs-2020/.gdbinit&quot; auto-loading has been declined by your `auto-load safe-path&#x27; set to &quot;$debugdir:$datadir/auto-load&quot;.<br>To enable execution of this file add<br>        add-auto-load-safe-path /home/cs18/myproj/6.828/xv6-labs-2020/.gdbinit<br>line to your configuration file &quot;/home/cs18/.gdbinit&quot;.<br>To completely disable this security protection add<br>        set auto-load safe-path /<br>&lt;q to quit, c to continue without paging--<br>line to your configuration file &quot;/home/cs18/.gdbinit&quot;.<br>For more information about this security protection see the<br>&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:<br>        info &quot;(gdb)Auto-loading safe path&quot;<br>(gdb) <br></code></pre></td></tr></table></figure><p>在我的机器上给出了一些报错，阅读之后，不难发现是因为我的默认<code>.gdbinit</code>屏蔽了交叉编译工具中的Gdb，在报错提示的地方加入相应的命令即可。</p><p>修改之后，再次运行<code>gdb</code>，这一次就可以开始愉快地debug之旅了！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  xv6-labs-2020 git:(traps) ✗ riscv64-unknown-elf-gdb <br>GNU gdb (GDB) 10.1<br>Copyright (C) 2020 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type <span class="hljs-string">&quot;show copying&quot;</span> and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf&quot;</span>.<br>Type <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>.<br>The target architecture is <span class="hljs-built_in">set</span> to <span class="hljs-string">&quot;riscv:rv64&quot;</span>.<br>warning: No executable has been specified and target does not support<br>determining executable automatically.  Try using the <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-built_in">command</span>.<br>0x0000000000001000 <span class="hljs-keyword">in</span> ?? ()<br>(gdb) b _entry<br>Breakpoint 1 at 0x8000000a<br>(gdb) c<br>Continuing.<br><br>Breakpoint 1, 0x000000008000000a <span class="hljs-keyword">in</span> _entry ()<br>=&gt; 0x000000008000000a &lt;_entry+10&gt;:      f3 25 40 f1     csrr    a1,mhartid<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一题x】思维-移动序列</title>
    <link href="/2021/06/17/tj210617/"/>
    <url>/2021/06/17/tj210617/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/3689/">移动序列</a></p><p>给01串（其中必然有1），只能按照以下的规则移动：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210617140146.png" alt="image-20210617140139500">求如何通过最小的次数让所有的1聚在一起。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有想明白，写了一个bfs搜索，毫不意外地tle了。</p><p><del>看了题解之后恍然大悟</del>。注意到，从起始串到最后的目标串，区别在于中间的0全部被消除了，换而言之，最优的方案实际上就是逐个填充0，只要计算出两个1之间间隔的0个数。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>不需要考虑只有一个1的corner case，我们每次遍历的时候从1开始，遍历到下一个1开始，中间的长度就是0的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">51</span>;<br><span class="hljs-keyword">int</span> a[N];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span>&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-keyword">int</span> n;<span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> zero_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; a[i] == <span class="hljs-number">1</span>)i++;<br>                <span class="hljs-keyword">int</span> begin = i;<br>                <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; a[i]==<span class="hljs-number">0</span>)i++;<br>                <span class="hljs-keyword">int</span> end = i;<br>                <span class="hljs-keyword">if</span>(end &lt; n)zero_count += end-begin;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">cout</span>&lt;&lt;zero_count&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一题x】预测赢家</title>
    <link href="/2021/06/16/tj210616-lc/"/>
    <url>/2021/06/16/tj210616-lc/</url>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>原题是力扣486.</p></blockquote><p>类似于拿石子问题，两个人依次从石子堆中取走石子，最后获得石子数量最多的人获胜。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题一开始并没有想出来怎么做，不过可以发现，贪心显然是错误的策略，故而理论上是需要对所有的状态空间进行搜索的。不过题目的数据规模下，搜索并不是一个可行的解决方案，注意到我们实际上只关心当游戏进行到某一个状态时，当前某一方最优的局面（假设玩游戏的两方都是绝对聪明的），故而可以使用<code>dp[i][j]</code>表示当前取到下标<code>i</code>到<code>j</code>（包括两者）的石子时，最大的石子数量<strong>差值</strong>。</p><blockquote><p>我觉得这个是比较难以想到的部分，不是记录某一方可以获得的最大值，而是记录一个相对值。好处就是状态转移十分自然。</p></blockquote><p>那么在扩张到<code>i, j</code>这样的区间上时，应该是从<code>i+1,j</code>或<code>i, j-1</code>两个状态上进行转移，<code>dp[i][j] = max(nums[i]-dp[i+1][j], nums[j]-piles[i][j-1])</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(nums.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.size(), <span class="hljs-number">0</span>));<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;len&lt;=nums.size();len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;nums.size();i++)&#123;<br>                <span class="hljs-keyword">int</span> j = i+len<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(i==j)&#123;<br>                    dp[i][j] = nums[i];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = max(nums[i]-dp[i+<span class="hljs-number">1</span>][j], nums[j]-dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][nums.size()<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前序后序那点事】怎么根据前序后序确定树的数量？</title>
    <link href="/2021/05/09/tj-210509/"/>
    <url>/2021/05/09/tj-210509/</url>
    
    <content type="html"><![CDATA[<h3 id="背景（NJU-19年保研机试题）"><a href="#背景（NJU-19年保研机试题）" class="headerlink" title="背景（NJU 19年保研机试题）"></a>背景（NJU 19年保研机试题）</h3><p>每一个上过数据结构课的人都知道，我们不一定可以通过前序遍历和后序遍历唯一地确定一棵树——不过，我们能够算出来有多少种可能的方案吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前序遍历对原树是如下的划分：</p><p><code>[root] [left] [right]</code></p><p>后序遍历是类似的：</p><p><code>[left] [right] [root]</code></p><p>但是，可能存在如下情况：</p><blockquote><p>前序：<code>1 2 3</code></p><p>后序：<code>3 2 1</code></p></blockquote><p>我们只能确定<code>2 3</code>在同一棵子树中，但是我们无法确定他们在那一棵子树中，这就是前、后序遍历无法确定子树的情况。当出现该情况时， 当前子树的可能构型为子树的可能构型*2；对于有两棵子树的，当前子树的构型为其左右子树构型数量的积。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">int</span> l1, <span class="hljs-keyword">int</span> r1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; post, <span class="hljs-keyword">int</span> l2, <span class="hljs-keyword">int</span> r2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l1&gt;r1 || l2&gt;r2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> root_ind = find(pre.begin(), pre.end(), post[r2])-pre.begin();<br>    <br>    <span class="hljs-keyword">if</span>(l1==r1)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">int</span> left_ind = find(post.begin(), post.end(), pre[l1+<span class="hljs-number">1</span>])-post.begin();<br>        <span class="hljs-keyword">if</span>(left_ind == r2<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> dfs(pre, l1+<span class="hljs-number">1</span>, r1, post, l2, r2<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> dfs(pre, l1+<span class="hljs-number">1</span>, l1+<span class="hljs-number">1</span>+left_ind-l2, post, l2, left_ind) * dfs(pre, l1+<span class="hljs-number">2</span>+left_ind-l2, r1, post, left_ind+<span class="hljs-number">1</span>, r2<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br><br>    vector&lt;int&gt; pre(n), post(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;pre[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;post[i];<br>    &#125;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;dfs(pre, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, post, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>保研</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一题】X数之和</title>
    <link href="/2021/04/26/tj-0421/"/>
    <url>/2021/04/26/tj-0421/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>两数之和是力扣上的第一个题，我至今记得当时做到的时候怀疑自己智商（毕竟大一没有学过什么是哈希表）。我们今天讨论一个简单的问题：</p><blockquote><p>给定一系列数，以及一个目标值，请输出所有和为目标值的组合（不可重复）。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看起来有一点吓人，我们从最简单的情况开始思考。</p><hr><h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>最简单的做法是遍历+哈希，每次遇到一个数字，判断<strong>目标值-当前数字</strong>是否已经存在，如果存在，则两者可以组成一个组合。稍微修改一下可以去重。</p><p>如果数组有更强的性质——有序性（下文假设数组是单调递增的），那么这个问题可以通过一趟单纯的遍历完成：</p><p>使用两个指针分别指向数组的开始与结尾，任何时刻，如果两个指针指向的数字之和等于目标值，那么就是一个方案；如果小于，那么移动左侧指针，反之移动右侧指针。</p><p>怎么去重？当我们的左指针向右移动时，判断其是否与上一个位置相同即可。</p><hr><p>怎么样，是不是很简单？我们来试试三数之和。三数之和，多了一个维度，我们可以枚举第一维，转化成一个两数之和问题。</p><p>怎么判重？与两数之和一样。</p><p>四数之和呢？同理，我们只需要枚举前两个维度。X数之和呢？我想你一定可以快速反应过来枚举前X-2个维度了，是不是很简单呢？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大道至简，X数之和实际上可以退化成X-1数之和，依次递减……不过现实中很多问题没有这样的性质，有时候不要太固执于将一个问题转化成熟悉的问题，具体问题具体分析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【设计模式】创造型模式</title>
    <link href="/2021/04/24/dp-factory/"/>
    <url>/2021/04/24/dp-factory/</url>
    
    <content type="html"><![CDATA[<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424201615.png" alt="image-20210424201608371"></p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>该模式中，定义一个抽象的产品以及抽象的工厂，具体产品与工厂的实现交给用户。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424201708.png" alt="image-20210424201708814"></p><p>在具体实现中，可以利用Java的<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264799402020448">反射机制</a>来避免修改代码。</p><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><p>课程ppt上的说法是，“客户端不需要知道具体类，只需要知道其对应的工厂”。ppt上的表达我认为有一点含糊，真实的原因应该是“客户端不需要知道具体类以及其如何被构造，只需要知道其对应的工厂”。原因在于，我们可能需要生成一个<code>html</code>文件，但是具体使用哪一个类去生成，这样的细节交给具体的工厂方法去考虑吧！</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424202631.png" alt="image-20210424202630979"></p><p>与工厂方法的最大区别在于，一个工厂方法往往只负责一种产品的创建，而抽象工厂则是负责多个产品的创建。</p><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>与工厂方法相同，不过对应的抽象产品是多个，并且我们认为<strong>同一个抽象工厂中的产品是同一个产品族的</strong>（美的的空调不可以和格力的一块使用！）。</p><h4 id="适用场合-1"><a href="#适用场合-1" class="headerlink" title="适用场合"></a>适用场合</h4><p>当我们需要创建一系列的产品时。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424204228.png" alt="image-20210424204228809"></p><h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424204415.png" alt="image-20210424204415061"></p><p>有意思是<code>Director</code>，可以理解为是<strong>创建的一个脚本</strong>。</p><p><code>Director</code>是可以省略的。</p><h4 id="适用场合-2"><a href="#适用场合-2" class="headerlink" title="适用场合"></a>适用场合</h4><ol><li>需要建立的产品构造比较复杂；</li><li>产品的属性相互依赖（DAG），需要指明生成顺序；</li><li>对象的创建过程独立于创建该对象的类；</li><li>隔离复杂对象的创建以及使用。</li></ol><blockquote><p><code>hadoop</code>中的<code>Configuration</code>就是建造者模式。</p></blockquote><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424205446.png" alt="image-20210424205446183"></p><h4 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424205636.png" alt="image-20210424205636721"></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210424210312.png" alt="image-20210424210312667"></p><h4 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h4><p>只有一个实例。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【思维】下一个排列</title>
    <link href="/2021/04/20/tj-210420/"/>
    <url>/2021/04/20/tj-210420/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://leetcode-cn.com/problems/next-permutation/">力扣，下一个排列</a></p><p>给定一个数字排列，求出字典序下的下一个排列。</p><h3 id="思路与解答"><a href="#思路与解答" class="headerlink" title="思路与解答"></a>思路与解答</h3><p><del>没有想出来</del></p><p>本题实际上就是让我们调整数字的顺序，恰好获得字典序下的下一个排列，听起来很简单，但是其中有挺多细节：</p><ol><li>怎么<strong>正好</strong>生成下一个排列？</li><li>遇到升序、降序的corner case如何处理？</li></ol><blockquote><p> 自己当时陷进了DFS的思维定式，没有想到直接从字典序本身考虑，说明我自身的算法思维还是存在一定的缺陷。</p></blockquote><p>首先写几组数字观察一下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">1<span class="hljs-number"> 2 </span>3<br>1<span class="hljs-number"> 3 </span>2<br>2<span class="hljs-number"> 1 </span>3<br>2<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 1 </span>2<br>3<span class="hljs-number"> 2 </span>1<br>1<span class="hljs-number"> 2 </span>3<br>. . .<br></code></pre></td></tr></table></figure><p>可以发现，字典序变大的过程实际上就是数组中逆序对变多的过程（<del>不过感觉这个观察没有什么用啊岂可修</del>），更具体地，一个任意区间的字典序最大为所有数字非增排列，如果想要继续增加，那么必然需要<strong>进位</strong>，也就是将该段数组中的一个元素与该区间外的一个小数字进行交换，然后将该区间之内的数字全部升序。</p><p>例如，<code>1 3 2</code>中，3 2是尾部的非增区间，此时无论尾部怎么调换，必然无法增加字典序，就需要将其中最小的一个数字与该区间左侧第一个元素进行交换，也就是2与1交换，得到<code>2 3 1</code>，不过这样一来并不是<code>1 3 2</code>的下一个排列，我们需要将原先的区间倒置，其此时必然变成一个升序排列，并且一定是原先排列的下一个排列。</p><p>我们再用一个特殊的例子看一下：<code>3 2 1</code>，由于尾部非增区间实际上就已经是整个数组，故而一定无法继续递增字典序，跳过了交换数字的过程，直接将整个区间逆转。</p><p>总结该算法：</p><ol><li>找到尾部最长的<strong>非增序列</strong>，不是递减是因为可能存在相同的数字；</li><li>如果非增区间已经是整个数组，那么直接进入下一步；否则，在非增区间中找到最小的大于非增区间左侧第一个元素的值，交换他们（形象地说，就是进位）；</li><li>将非增区间逆转。</li></ol><blockquote><p>实际上，C++ STL中的next_permutation就是使用的这个算法。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>注意到非增区间具有有序性，故而查找可以使用二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> j = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; nums[j<span class="hljs-number">-1</span>]&gt;=nums[j])&#123;<span class="hljs-comment">// 找到分界点</span><br>            j--;<br>        &#125;<br><br><br>        reverse(nums.begin()+j, nums.end());<span class="hljs-comment">// 保持有序，否则无法进行二分查找</span><br><br>        <span class="hljs-keyword">if</span>(j)&#123;<br>            <span class="hljs-keyword">int</span> i = j<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> ind = upper_bound(nums.begin()+j,nums.end(), nums[i])-nums.begin();<br>            <span class="hljs-keyword">if</span>(ind!=nums.size())<br>                swap(nums[i], nums[ind]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>算法</tag>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【A*算法】八数码</title>
    <link href="/2021/04/19/tj-210419/"/>
    <url>/2021/04/19/tj-210419/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/181/">八数码</a></p><p>题意非常简单，给你一个八数码，如果其有解，输出一个最优解并且给出路径；如果没有则输出<code>unsolvable</code>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是一道好题目，涉及到了以下几个知识点：</p><ol><li>如何优化盲目搜索（A*算法）</li><li>如何有效存取数码（康托散列）</li><li>如何输出路径</li></ol><p>其中后两点不是这篇博文的主要话题，感兴趣的读者可以自行阅读代码理解或者查阅其他文章，本文主要就题谈谈简单的A*算法。</p><h5 id="什么是A-算法？"><a href="#什么是A-算法？" class="headerlink" title="什么是A*算法？"></a>什么是A*算法？</h5><p>一言以蔽之，就是基于优先队列的BFS算法，其中排序的依据是自定义的一个启发函数。问题来了，<strong>怎么定义启发函数？</strong>好的启发函数显然能够让状态空间大大缩小，但代价函数也不应该过于复杂。但无论如何，</p><blockquote><p> <strong>启发函数估算出的代价一定不能大于真实的代价</strong>。</p></blockquote><p>如果没有这样的约束，那么我们可能错误估计一个真实最优状态的代价，从而导致在错误分支上搜索。</p><p>就八数码问题而言，<strong>曼哈顿距离</strong>是一个不错的代价函数。一来，每个位置上的元素与其应该在的距离确实衡量了其与目标状态的距离，并且这样的估值是显然小于真实估值的。</p><blockquote><p><strong>为什么？</strong></p><p>思考如下的一种情况</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">---</span>|<br>|<span class="hljs-string">3 2</span>|<br>|<span class="hljs-string">1 0</span>|<br>|<span class="hljs-string">---</span>|<br></code></pre></td></tr></table></figure><p>通过曼哈顿距离，计算出的估值是2（1,3不在原位），也就是对应两个节点直接交换——而这是不允许的。最好情况下，曼哈顿距离恰好与真实值相等，但往往是小于真实值的。</p></blockquote><h5 id="仅仅如此，够了吗？"><a href="#仅仅如此，够了吗？" class="headerlink" title="仅仅如此，够了吗？"></a>仅仅如此，够了吗？</h5><p>有了状态，我们还需要去考虑如何保留状态。最简单的想法，我们直接使用一个字符串记录当前的状态，每次使用的时候还原即可。换而言之，基于<code>map</code>。实际上，有一种叫做<em>康托散列</em>的方法，可以快速计算（平方时间，不过此处可以当做常数）一个排列的散列，确切地说，是将其映射到1-N!之间。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>搜索题算法实现往往比较复杂，我在写本题的时候因为如下原因wa多次：</p><ol><li>typo</li><li>实现错误</li><li>效率不够</li></ol><p>最终AC算法如下（Acwing 10个点，共耗时136ms）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span><br>    <span class="hljs-comment">// l: 当前地图中0的位置</span><br>    <span class="hljs-comment">// dist: 实际已经走的距离 + 预测还要走的距离</span><br>    <span class="hljs-comment">// m: 地图表示的字符串</span><br>    <span class="hljs-keyword">int</span> l;<br>    <span class="hljs-keyword">int</span> dist;<br>    <span class="hljs-built_in">string</span> m;<br>    rec(<span class="hljs-keyword">int</span> l_,<span class="hljs-built_in">string</span> m_, <span class="hljs-keyword">int</span> dist_):l(l_),m(m_), dist(dist_)&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> rec&amp; a,<span class="hljs-keyword">const</span> rec&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a.dist &gt; b.dist;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<br><span class="hljs-comment">// d: &lt;序列化值对应, 到当前状态的最小距离&gt;</span><br><span class="hljs-comment">// f: &lt;序列化值, 上一步&gt;</span><br><span class="hljs-comment">// go: &lt;序列化值, 对应的cmd&gt;</span><br><span class="hljs-comment">// q: A*状态的优先队列</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">362886</span>;<br><span class="hljs-keyword">int</span> d[N];<br><span class="hljs-keyword">int</span> f[N];<br><span class="hljs-keyword">int</span> go[N];<br><span class="hljs-built_in">priority_queue</span>&lt;rec&gt; q;<br><br><br><span class="hljs-comment">// 模拟`x`运动</span><br><span class="hljs-keyword">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">char</span> cmd[] = &#123;<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>&#125;;<br><br><span class="hljs-comment">// cantor hash</span><br><span class="hljs-keyword">int</span> fac[<span class="hljs-number">11</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initFac</span><span class="hljs-params">()</span></span>&#123;<br>    fac[<span class="hljs-number">0</span>] = fac[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> ;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>        fac[i] = i*fac[i<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用cantor散列法求出排列的散列值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.size();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j]&lt;s[i])temp++;<br>        &#125;<br>        res += (temp) * fac[len-i<span class="hljs-number">-1</span>];    <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> len = s.size();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">int</span> x = i/<span class="hljs-number">3</span>, y = i%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> cur = s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>) ret+= <span class="hljs-built_in">abs</span>(x<span class="hljs-number">-2</span>)+<span class="hljs-built_in">abs</span>(y<span class="hljs-number">-2</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> fx = (cur<span class="hljs-number">-1</span>)/<span class="hljs-number">3</span>, fy = (cur<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>;<br>            ret += <span class="hljs-built_in">abs</span>(x-fx)+<span class="hljs-built_in">abs</span>(y-fy);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; start, <span class="hljs-keyword">int</span> dist, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; e)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">memset</span>(go,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> go);<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    q.push(rec(l, start, dist));<br>    d[cantor(start)] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q.size())&#123;<br>        <br>        rec cur = q.top();q.pop();<br>        <span class="hljs-keyword">if</span>(cur.m==e)&#123;<br>            <span class="hljs-keyword">return</span> d[cantor(cur.m)];<br>        &#125;<br>        <span class="hljs-function">pii <span class="hljs-title">pos</span><span class="hljs-params">(cur.l/<span class="hljs-number">3</span>,cur.l%<span class="hljs-number">3</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> val = cantor(cur.m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-keyword">int</span> x = pos.first + dx[i], y = pos.second + dy[i];<br>            <span class="hljs-built_in">string</span> m = cur.m;<br>            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;<span class="hljs-number">3</span> &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;<span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">int</span> pos_to_swap = x*<span class="hljs-number">3</span> + y;<br>                swap(m[cur.l],m[pos_to_swap]);<br>                <span class="hljs-keyword">int</span> dumpVal = cantor(m);<br>                <span class="hljs-keyword">if</span>(d[dumpVal]==<span class="hljs-number">-1</span> || d[dumpVal]&gt;d[val]+<span class="hljs-number">1</span>)&#123;<br>                    d[dumpVal] = d[val]+<span class="hljs-number">1</span>;<br>                    f[dumpVal] = val;<br>                    go[dumpVal] = i;<br>                    q.push(rec(pos_to_swap,m,d[dumpVal]+evaluate(m)));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[val]==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    print(f[val]);<br>    <span class="hljs-built_in">putchar</span>(cmd[go[val]]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    initFac();<br>    <span class="hljs-built_in">string</span> e = <span class="hljs-string">&quot;123456780&quot;</span>;<br>    <br>    <span class="hljs-built_in">string</span> start;<br>    <span class="hljs-keyword">int</span> l ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-keyword">char</span> tem;<span class="hljs-built_in">cin</span>&gt;&gt;tem;<br>        <span class="hljs-keyword">if</span>(tem==<span class="hljs-string">&#x27;x&#x27;</span>)tem=<span class="hljs-string">&#x27;0&#x27;</span>, l = i;<br>        start.append(<span class="hljs-number">1</span>,tem);<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">// 判断是否理论上不可行</span><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; start.size(); i++)<br><span class="hljs-keyword">if</span> (start[i] != <span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br><span class="hljs-keyword">if</span> (start[j] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start[j] &gt; start[i]) ++cnt;<br><span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;unsolvable&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>    <span class="hljs-keyword">auto</span> ret = bfs(l,start,evaluate(start),e);<br>    <br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        print(cantor(e));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;unsolvable\n&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 5 3 x 7 8 2 4 6 1</span><br><span class="hljs-comment">// 6 4 7 8 5 x 3 2 1</span><br><span class="hljs-comment">// 4 7 x 1 3 6 8 5 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>搜索</tag>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日学习】SpringBoot-JPA基本CURD以及Postman使用</title>
    <link href="/2021/04/18/daily-210418/"/>
    <url>/2021/04/18/daily-210418/</url>
    
    <content type="html"><![CDATA[<h3 id="快速总结"><a href="#快速总结" class="headerlink" title="快速总结"></a>快速总结</h3><ul><li>快速上手了一下SpringBoot，主要是看官方文档中的<code>quick-start</code>部分以及参考了这一篇<a href="https://bezkoder.com/spring-boot-jpa-crud-rest-api/">非常详细的教程</a>。虽然是很小的一步，但是感觉在后端的路上也算是打出了<code>Hello World</code></li><li>学习了如何使用<code>Postman</code>进行<code>http</code>的调试</li></ul><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><blockquote><p>以下部分会涉及到许多个人的主观理解，也只用于个人日后回顾。</p></blockquote><h4 id="SpringBoot程序的基本架构"><a href="#SpringBoot程序的基本架构" class="headerlink" title="SpringBoot程序的基本架构"></a>SpringBoot程序的基本架构</h4><p>目前我只涉及到了<code>Application,Controller</code>，前者用于启动一个<code>SpringBoot</code>程序，后者作为<code>MVC</code>架构中的<code>controller</code>，起到映射<code>RESTFUL</code>接口的作用。</p><p>一个典型的<code>SpringBoot Application</code>长这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bezkoder.spring.datajpa;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.CommandLineRunner;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(Application.class, args);<br>&#125;<br>    <br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>@</code>开头的是<code>Java</code>中的注解语法，<code>@SpringBootApplication</code>表示当前类的作用。</p><p>一个典型的<code>SpringBoot Controller</code>则长这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.bezkoder.spring.datajpa.controller;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> com.bezkoder.spring.datajpa.model.Tutorial;<br><span class="hljs-keyword">import</span> com.bezkoder.spring.datajpa.repository.TutorialRepository;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TutorialController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    TutorialRepository tutorialRepository;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/tutorials&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Tutorial&gt;&gt; getAllTutorials(<span class="hljs-meta">@RequestParam(required = false)</span> String title) &#123;<br>       <br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/tutorials/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Tutorial&gt; <span class="hljs-title">getTutorialById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">long</span> id)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/tutorials&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Tutorial&gt; <span class="hljs-title">createTutorial</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Tutorial tutorial)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/tutorials/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Tutorial&gt; <span class="hljs-title">updateTutorial</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">long</span> id, <span class="hljs-meta">@RequestBody</span> Tutorial tutorial)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/tutorials/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;HttpStatus&gt; <span class="hljs-title">deleteTutorial</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">long</span> id)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/tutorials&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;HttpStatus&gt; <span class="hljs-title">deleteAllTutorials</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/tutorials/published&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Tutorial&gt;&gt; findByPublished() &#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码略去了一些细节，其中有两个需要注意的注解：</p><ul><li><code>@RestController</code>：和<code>SpringBootApplication</code>的作用类似，看文档说该注解实际上起到了一些自动配置的作用，日后总结；</li><li><code>@RequestMapping(/..)</code>：用于告知所有Api 的url将会映射到<code>/..</code>开头。比如，上面的<code>index</code>函数，对应的是<code>localhost:8080/api/test</code>页面的结果。</li></ul><h4 id="使用JPA-Hibernate快速完成CRUD接口"><a href="#使用JPA-Hibernate快速完成CRUD接口" class="headerlink" title="使用JPA,Hibernate快速完成CRUD接口"></a>使用JPA,Hibernate快速完成CRUD接口</h4><p>后端交互的基础就是<code>CRUD</code>，而这部分的代码实际上是比较格式化的，我们可以通过一些工具来帮助我们完成这部分代码的生成。</p><h5 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h5><p>参见前文的文章。</p><h5 id="Data-Model类"><a href="#Data-Model类" class="headerlink" title="Data Model类"></a>Data Model类</h5><p>我们需要创建一个Data Model类来定义将要操作的数据，大体内容可以参见前文的文章。常见的注解有：</p><ul><li><code>@Entity</code>：注明这是一个持久的Java Class（没有明白）</li><li><code>@Table</code>：注明这是一个表</li><li><code>@Column</code>：注明这是一列</li><li><code>@Id</code>：注明这是id</li></ul><h5 id="用于与Data-Model-交互的Repository类"><a href="#用于与Data-Model-交互的Repository类" class="headerlink" title="用于与Data Model 交互的Repository类"></a>用于与Data Model 交互的Repository类</h5><p>为了使用<code>JPA</code>来完成我们与<code>Data Model</code>的交互，我们需要继承<code>JpaRepository</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TutorialRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Tutorial</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;<br>    <span class="hljs-function">List&lt;Tutorial&gt; <span class="hljs-title">findByPublished</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> published)</span></span>;<br>    <span class="hljs-function">List&lt;Tutorial&gt; <span class="hljs-title">findByTitleContaining</span><span class="hljs-params">(String title)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，我们就可以使用<code>Jpa</code>提供的各种接口啦！</p><h5 id="完成RESTFUL接口"><a href="#完成RESTFUL接口" class="headerlink" title="完成RESTFUL接口"></a>完成<code>RESTFUL</code>接口</h5><p>什么是<code>RESTFUL</code>接口？我觉得阮一峰<a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">这篇文章</a>讲的通俗易懂。这个术语的全称是<code>Representation state transfer</code>，阮一峰的翻译是“表现层状态转移”，听起来挺抽象的。我个人的理解是，将<code>URL</code>看成实体，通过<code>HTTP</code>中的四种操作完成对实体（资源）的各种操作。</p><p>我们最后需要使用<code>SpringBoot</code>完成这一任务，实际上，前文的<code>Controller</code>中的接口就是<code>RESTFUL</code>的。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虽然跑完了一个简单的<code>demo</code>，但是我对<code>SpringBoot</code>中的<strong>几乎所有</strong>细节都是不清楚的，所以现在自己心里也是比较发毛的。万里长征，始于足下，一天一点进步吧！</p><h4 id="Postman使用"><a href="#Postman使用" class="headerlink" title="Postman使用"></a>Postman使用</h4><p>在完成了上述的基本架构，并且让<code>SpringBoot</code>跑起来之后，我们当然要去测试一下我们的接口有没有问题啦！怎么测试呢？最简单的方法当然就是模拟一下<code>http</code>请求了，而<code>postman</code>就是这样一个工具。</p><p>在如下界面中选择不同的<code>http</code>操作，填入相应的字段即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210418233208.png" alt="image-20210418233208145"></p><blockquote><p><strong>注意</strong>：如果是<code>POST</code>，我的<code>springboot</code>必须要将类型设置为<code>json</code>，否则会报错415</p></blockquote><p>这里踩了一个坑，就是无法需要通过<code>Postman</code>的本地agent来访问测试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Postman</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每周一题】扰乱字符串</title>
    <link href="/2021/04/18/tj210418/"/>
    <url>/2021/04/18/tj210418/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://leetcode-cn.com/problems/scramble-string/">力扣87</a></p><p>大意是给定两个字符串，是否可以通过对其中一个字符串不断分裂、交换获得第二个字符串。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一次尝试暴力，脑补了一下觉得不太能写的出来（其实这个时候感觉可以动归，但是只能想到简单的记录状态），看了题解之后<del>恍然大悟</del>，发现还是一道值得一提的题目。</p><p>我认为比较好的做法就是官方题解中给出的做法，也就是<strong>动态规划</strong>。看看要素：</p><ol><li>子问题重叠性。显然，两个子串是否可以最终等价是状态，这样的状态会被重复计算；</li><li>最优子结构。本题属于<strong>可行</strong>判断，故而如果两个子串是否匹配被计算出来，其必然就是最后的结果；</li><li>无后效性。显然是满足的。</li></ol><p>接下来看状态、阶段以及决策。</p><p>状态已经提及了，简单说来就是两个子串以及匹配的长度，官方题解中将其简化成了一个<code>&lt;i,j,len&gt;</code>的三元组（将原字符串当成成员变量，类似于全局变量）。</p><p>阶段和决策，常见的处理方法是<code>push</code>（使用一个状态去更新其他状态）或者<code>pull</code>（从其他状态更新当前的状态）。本题实际上更适合第三种方法——记忆化搜索。记忆化搜索就是在暴力搜索的过程中记录已经访问过的状态，避免重复访问（bfs里也有类似的思想）。本题由于具有递归的结构，使用记忆化搜索也是很好写的。如何决策？这其实就是本题的状态转移方程是什么。这里直接使用官方题解给出的图示：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210418131525.png" alt="fig1"></p><p>一图胜千言，简单说来，就是交换或者不交换，对于每一种状态，枚举中间节点即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">string</span> s1;<br>    <span class="hljs-built_in">string</span> s2;<br>    <span class="hljs-keyword">int</span> vis[<span class="hljs-number">31</span>][<span class="hljs-number">31</span>][<span class="hljs-number">31</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatched</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1,<span class="hljs-keyword">int</span> i2, <span class="hljs-keyword">int</span> length)</span></span>&#123;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            hash[s1[i1+i]]++;<br>            hash[s2[i2+i]]--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> !any_of(hash.begin(), hash.end(),[&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e)&#123;<span class="hljs-keyword">return</span> e.second!=<span class="hljs-number">0</span>;&#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, <span class="hljs-keyword">int</span> length)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(vis[i1][i2][length])&#123;<br>            <span class="hljs-keyword">return</span> vis[i1][i2][length] == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(s1.substr(i1,length)==s2.substr(i2,length))&#123;<br>             <span class="hljs-keyword">return</span> vis[i1][i2][length] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!isMatched(i1,i2,length))&#123;<br>            vis[i1][i2][length] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// no swap</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;k&lt;length;k++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(i1,i2,k) &amp;&amp; dfs(i1+k, i2+k, length-k))&#123;<br>                <span class="hljs-keyword">return</span> vis[i1][i2][length] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// swap</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;k&lt;length;k++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(i1+length-k,i2,k) &amp;&amp; dfs(i1,i2+k,length-k))&#123;<br>                <span class="hljs-keyword">return</span> vis[i1][i2][length] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        vis[i1][i2][length] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isScramble</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>        <span class="hljs-keyword">this</span>-&gt;s1 = s1;<br>        <span class="hljs-keyword">this</span>-&gt;s2 = s2;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s1.size());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sort函数自定义比较</title>
    <link href="/2021/04/12/log-210412/"/>
    <url>/2021/04/12/log-210412/</url>
    
    <content type="html"><![CDATA[<h3 id="发生了啥？"><a href="#发生了啥？" class="headerlink" title="发生了啥？"></a>发生了啥？</h3><p>在做leetcode 每日一题<a href="https://leetcode-cn.com/problems/largest-number/">最大数</a>的过程中，自定义了一个如下的比较函数用于<code>sort</code>排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-built_in">string</span> sa = to_string(a);<br>        <span class="hljs-built_in">string</span> sb = to_string(b);<br>        <span class="hljs-keyword">return</span> sa+sb&gt;=sb+sa;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后愉快地报错了（可以尝试输入多个0，不过该问题在只有比较少0的时候不会出现）。</p><p>解决办法是将上面比较函数中的大于等于改为大于。</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>遇事不决，先问<code>StackOverflow</code>，果不其然，遇到了一个有相似问题的大哥，得到了如下的解答：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210412124947.png" alt="image-20210412124940043"></p><p>啊，原来这么简单！</p><p>点进<a href="https://en.cppreference.com/w/cpp/named_req/Compare">compare requirement</a>，可以看到cpp对于custome cmp的要求：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210412125113.png" alt="image-20210412125113182"></p><p>简单说来，就是满足自反性、反对称性以及传递性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个小小的细节，可能平时不太会犯这样的错误，不过还是十分值得注意的！</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的传参问题</title>
    <link href="/2021/03/28/daily-210328/"/>
    <url>/2021/03/28/daily-210328/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在学习Java，我一直有一个<strong>疑惑</strong>——Java中的传参究竟是什么方式？pass by value？pass by reference？还是会变化？在PL课上，老师讲到了如下的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210328204656.png" alt="image-20210328204649012"></p><p>在这个问题中，答案又应该是什么呢？</p><h3 id="思考与解答"><a href="#思考与解答" class="headerlink" title="思考与解答"></a>思考与解答</h3><p>首先说结论，我认为Java中的传参都可以看做是pass by value；如果参数是一个对象，那么实际上传递的就是一个指向对象的指针的拷贝。</p><p>我们看这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JavaPlayGround;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        Dog myDog = <span class="hljs-keyword">new</span> Dog();<br>        myDog.setAge(<span class="hljs-number">2</span>);<br>        System.out.println(myDog.getAge()); <span class="hljs-comment">// 2</span><br>        fooByModify(myDog);<br>        System.out.println(myDog.getAge());<span class="hljs-comment">// 11</span><br><br>        myDog.setAge(<span class="hljs-number">2</span>);<br>        fooByAssign(myDog);<br>        System.out.println(myDog.getAge());<span class="hljs-comment">// 2</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fooByModify</span><span class="hljs-params">(Dog d)</span></span>&#123;<br>        d.setAge(<span class="hljs-number">11</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fooByAssign</span><span class="hljs-params">(Dog d)</span></span>&#123;<br>        d = <span class="hljs-keyword">new</span> Dog();<br>        d.setAge(<span class="hljs-number">11</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的例子里，<code>fooByModify</code>与<code>fooByAssign</code>分别对传入的对象进行修改/赋值，而只有前者真正改了原先的对象，后者则对原先的对象没有任何影响。</p><p>我的理解如下：</p><p>不妨假设myDog指向地址3，那么调用<code>fooByModify</code>时，<code>d</code>也指向地址3（相当于复制了myDog的地址），故而之后的改变都会影响到地址3的myDog。</p><p>在调用<code>fooByAssign</code>时，事情有所不同。<code>d</code>一开始指向地址3，但是随后被赋值（记住，此处的<code>d</code>和myDog没有关系，它只是保存了一个地址罢了），故而<code>d</code>指向了一个新的地址，之后的修改也就自然没有任何变化了。</p><p>至于PL课上提出的问题，语焉不详（不清楚调用constructor之后的内部行为），无法给出详尽的解释。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">stackoverflow上的讨论</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>每日一问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【单调栈】132模式</title>
    <link href="/2021/03/24/tj210324/"/>
    <url>/2021/03/24/tj210324/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://leetcode-cn.com/problems/132-pattern/">leetcode 456</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>乍一看题目，以为是<strong>楼兰图腾</strong>，树状数组的裸题，但是仔细一看（一看就看了一个小时），发现其实没有那么简单。</p><p>不过所有看起来不简单的题目都是从简单的分析开始的。</p><p>最朴素的想法是枚举，枚举的对象应该是<script type="math/tex">j</script>或者<script type="math/tex">k</script>。</p><h4 id="对j枚举"><a href="#对j枚举" class="headerlink" title="对j枚举"></a>对<script type="math/tex">j</script>枚举</h4><p>如果对<script type="math/tex">j</script>枚举，那么显然我们需要求出两个集合：</p><ol><li>在<script type="math/tex">j</script>左侧的最小元素集合；</li><li>在<script type="math/tex">j</script>右侧的最大元素（并且不超过它）集合。</li></ol><p>前者只需要一次简单的遍历即可完成，而后者需要使用一些trick。最简单的方式是直接遍历一遍<script type="math/tex">j</script>右侧，找出不大于其的最大元素；仔细思考，我们可以维护右侧的最大值<strong>集合</strong>（第一种情况实际上维护了一个只有一个元素的集合，因为没有范围限制），对于每一个<script type="math/tex">j</script>，我们只需要在这个集合中找出解即可。</p><p>问题来了，什么数据结构？平衡树显然可以胜任，但是维护这个结构需要对数时间复杂度；一个更好的方案是使用一个单调栈。这并不是一个显然的结论，你很容易想到，如果维护一个单调递减的单调栈，那么对于某些元素，其可能因为之前一些元素的入栈，而丢失掉一些可能的解。但是，如果你仔细思考，你会发现，<strong>如果这样的元素是满足要求的，那么其之前的元素一定也是满足要求的，因为他们的最小元素集合更大</strong>。</p><p>故而，第一种思路就是：求出两个集合，比较右侧最大元素是否大于左侧最小元素（注意，此处暗含了<strong>当前元素大于左侧最小元素的比较</strong>）。</p><h4 id="对k枚举"><a href="#对k枚举" class="headerlink" title="对k枚举"></a>对<script type="math/tex">k</script>枚举</h4><blockquote><p> 如果你觉得第一种方案有一点点绕人，那么我建议你也不要看第二种方案了，因为它更简单，更绕人。</p></blockquote><p>对于<script type="math/tex">k</script>而言，我们应该从右往左遍历，因为需要解空间就是其左侧的元素。我们应该维护的是<script type="math/tex">j</script>位置元素的集合，并且<strong>保证当前的最大<script type="math/tex">k</script>应该是小于其中每一个元素的。</strong>这样的好处是什么呢？任何时刻，我们只要发现当前遍历的元素小于最大的<script type="math/tex">k</script>的值，就说明存在一个合法的<script type="math/tex">k</script>以及<script type="math/tex">j</script>！（所以在一开始应该将最大的<script type="math/tex">k</script>初始化为最小值）。</p><p>如何维护？我们维护一个当前最大<script type="math/tex">k</script>值以及一个单调栈（单调递减）。单调栈中一开始只有最后一个元素，当前最大<script type="math/tex">k</script>值一开始为最小值（下面称最小值）。</p><ol><li>如果当前元素小于最小值，那么已经找到了一个解（当前元素是<script type="math/tex">i</script>位置）；</li><li>如果当前的栈顶元素小于当前元素，那么按照单调栈方式维护，并更新最小值（当前元素是<script type="math/tex">j</script>位置），而被弹出的元素是<script type="math/tex">k</script>位置。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>此处给出第二种方法的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()&lt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> maxVal = INT_MIN;<br>    <br>        st.push(nums[nums.size()<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= nums.size()<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;maxVal)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">while</span>(st.size() &amp;&amp; st.top()&lt;nums[i])&#123;<br>                maxVal = max(maxVal, st.top());<br>                st.pop();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[i]&gt; maxVal)&#123;<br>                st.push(nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// [1,4,0,-1,-2,-3,-1,-2]</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>单调栈</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络复习】UDP</title>
    <link href="/2021/03/23/network-udp/"/>
    <url>/2021/03/23/network-udp/</url>
    
    <content type="html"><![CDATA[<h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><ol><li>不需要建立连接；</li><li>无状态；</li><li>分组首部开销较小（只有8B）；</li><li>应用层可以更好控制发包时间。</li></ol><h3 id="UDP的一些误区"><a href="#UDP的一些误区" class="headerlink" title="UDP的一些误区"></a>UDP的一些误区</h3><ol><li>UDP虽然是best-effort，但也是可以在应用层实现可靠传输的；</li><li>UDP的报文是不可分割的</li></ol><h3 id="UDP细节"><a href="#UDP细节" class="headerlink" title="UDP细节"></a>UDP细节</h3><h6 id="首部格式："><a href="#首部格式：" class="headerlink" title="首部格式："></a>首部格式：</h6><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code"> 0      7 8     15 16    23 24    31</span><br><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+<br>|     Source      |   Destination   |<br>|      Port       |      Port       |<br><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+<br>|                 |                 |<br>|     Length      |    Checksum     |<br><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+<br>|<br>|          data octets ...<br>+---------------- ...<br></code></pre></td></tr></table></figure><h6 id="checksum计算："><a href="#checksum计算：" class="headerlink" title="checksum计算："></a>checksum计算：</h6><ol><li>根据IPV4或IPV6添加伪首部（对IP数据报的源地址以及目的地址也进行校验）；</li><li>补全报文为B偶数倍；</li><li>以2B为单位计算反码和并取反</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络复习】TCP简单入门</title>
    <link href="/2021/03/23/network-tcp/"/>
    <url>/2021/03/23/network-tcp/</url>
    
    <content type="html"><![CDATA[<h3 id="TCP-的优点"><a href="#TCP-的优点" class="headerlink" title="TCP 的优点"></a>TCP 的优点</h3><p>与UDP相比，TCP可靠、面向连接。她有如下的一些特点：</p><ol><li>面向连接；</li><li>是点到点的；</li><li>提供可靠的交付服务，并且传送的数据无差错、不丢失、不重复并且有序；</li><li>全双工（双方都需要维护发送以及接受缓存）；</li><li>面向字节流的（seq,ack都是针对字节流的）</li></ol><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">TCP Header Format<br><br><br>    0                   1                   2                   3<br>    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">          Source Port          </span>|<span class="hljs-string">       Destination Port        </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">                        Sequence Number                        </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">                    Acknowledgment Number                      </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">  Data </span>|<span class="hljs-string">           </span>|<span class="hljs-string">U</span>|<span class="hljs-string">A</span>|<span class="hljs-string">P</span>|<span class="hljs-string">R</span>|<span class="hljs-string">S</span>|<span class="hljs-string">F</span>|<span class="hljs-string">                               </span>|<br>   |<span class="hljs-string"> Offset</span>|<span class="hljs-string"> Reserved  </span>|<span class="hljs-string">R</span>|<span class="hljs-string">C</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">Y</span>|<span class="hljs-string">I</span>|<span class="hljs-string">            Window             </span>|<br>   |<span class="hljs-string">       </span>|<span class="hljs-string">           </span>|<span class="hljs-string">G</span>|<span class="hljs-string">K</span>|<span class="hljs-string">H</span>|<span class="hljs-string">T</span>|<span class="hljs-string">N</span>|<span class="hljs-string">N</span>|<span class="hljs-string">                               </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">           Checksum            </span>|<span class="hljs-string">         Urgent Pointer        </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">                    Options                    </span>|<span class="hljs-string">    Padding    </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |<span class="hljs-string">                             data                              </span>|<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br><br>                            TCP Header Format<br></code></pre></td></tr></table></figure><p>具体的阐述参见：<a href="https://tools.ietf.org/html/rfc793#section-1.1">RFC TCP</a>。</p><p>与UDP相同的是，TCP的校验也采用伪首部，具体细节同样参见RFC 793。</p><blockquote><p>options可以用于确定MSS大小，最终取双方中较小值。</p></blockquote><h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p>TCP连接需要来回发送一共三条报文，也就是大名鼎鼎的“三次握手”。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bnf">TCP A                                                TCP B<br><br>  1.  CLOSED                                               LISTEN<br><br>  2.  SYN-SENT    --&gt; <span class="hljs-attribute">&lt;SEQ=100&gt;</span><span class="hljs-attribute">&lt;CTL=SYN&gt;</span>               --&gt; SYN-RECEIVED<br><br>  3.  ESTABLISHED <span class="hljs-attribute">&lt;-- &lt;SEQ=300&gt;</span><span class="hljs-attribute">&lt;ACK=101&gt;</span><span class="hljs-attribute">&lt;CTL=SYN,ACK&gt;</span>  <span class="hljs-attribute">&lt;-- SYN-RECEIVED</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  4.  ESTABLISHED --&gt;</span> <span class="hljs-attribute">&lt;SEQ=101&gt;</span><span class="hljs-attribute">&lt;ACK=301&gt;</span><span class="hljs-attribute">&lt;CTL=ACK&gt;</span>       --&gt; ESTABLISHED<br><br>  5.  ESTABLISHED --&gt; <span class="hljs-attribute">&lt;SEQ=101&gt;</span><span class="hljs-attribute">&lt;ACK=301&gt;</span><span class="hljs-attribute">&lt;CTL=ACK&gt;</span><span class="hljs-attribute">&lt;DATA&gt;</span> --&gt; ESTABLISHED<br><br>          Basic 3-Way Handshake for Connection Synchronization<br></code></pre></td></tr></table></figure><p>首先，TCP A发送一条报文（进入SYN-SENT状态），其中SYN位置1，表示这是一条请求TCP连接建立的报文；</p><p>其次，当TCP B接受到SYN位置1的报文时（进入SYN-RECEIVED状态），它发送一条SYN,ACK位均置1的报文，其中报文的ack号是接收到的报文seq加一（需要注意的是，上图2中的报文是没有携带任何数据的，但是依然需要消耗一个序列号！）；</p><p>最后，接收到TCP B发送报文的TCP A进入ESTABLISHED状态，并发送一条只有ACK置1的报文（这一条报文可以携带数据），表示连接建立成功。</p><blockquote><h6 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h6><p><a href="https://stackoverflow.com/questions/23771976/two-way-handshake-and-three-way-handshake">stackoverflow上的讨论</a><br><a href="https://www.nowcoder.com/tutorial/93/e1b14ab2b40a4ef98d9e55830eb48d66">牛客网上的面经</a></p><p>概括一下，三次握手可以防止old deplicated syn，避免服务器的资源空耗，统一双方的seq以及ack。</p></blockquote><h3 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h3><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bnf">TCP A                                                TCP B<br><br>  1.  ESTABLISHED                                          ESTABLISHED<br><br>  2.  (Close)<br>      FIN-WAIT-1  --&gt; <span class="hljs-attribute">&lt;SEQ=100&gt;</span><span class="hljs-attribute">&lt;ACK=300&gt;</span><span class="hljs-attribute">&lt;CTL=FIN,ACK&gt;</span>  --&gt; CLOSE-WAIT<br><br>  3.  FIN-WAIT-2  <span class="hljs-attribute">&lt;-- &lt;SEQ=300&gt;</span><span class="hljs-attribute">&lt;ACK=101&gt;</span><span class="hljs-attribute">&lt;CTL=ACK&gt;</span>      <span class="hljs-attribute">&lt;-- CLOSE-WAIT</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  4.                                                       (Close)</span><br><span class="hljs-attribute">      TIME-WAIT   &lt;-- &lt;SEQ=300&gt;</span><span class="hljs-attribute">&lt;ACK=101&gt;</span><span class="hljs-attribute">&lt;CTL=FIN,ACK&gt;</span>  <span class="hljs-attribute">&lt;-- LAST-ACK</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  5.  TIME-WAIT   --&gt;</span> <span class="hljs-attribute">&lt;SEQ=101&gt;</span><span class="hljs-attribute">&lt;ACK=301&gt;</span><span class="hljs-attribute">&lt;CTL=ACK&gt;</span>      --&gt; CLOSED<br><br>  6.  (2 MSL)<br>      CLOSED<br><br>                         Normal Close Sequence<br></code></pre></td></tr></table></figure><p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p><p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p><p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p><p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p><blockquote><h6 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h6><p>四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p></blockquote><h3 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h3><ol><li><p>序号</p><p>TCP为字节流维护序号，确保了数据在传递时的有序性</p></li><li><p>确认</p><p>TCP报文中指出希望对方发送的下一个报文的序号，并使用<strong>累计确认</strong>机制。该机制可以用于及时发现哪些报文丢失，及时重传</p></li><li><p>重传</p><p>在两种情况下重传：1. 报文段的计时器超时；2. 收到了冗余ACK</p></li></ol><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>着眼于点到点，确保连接双方的速率匹配，接收方通过TCP 报文中的rwnd字段来告诉发送方它还有多大的接受缓冲空间。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>着眼于网络全局，通过拥塞控制算法，TCP估计当前网络负载能力，计算出cwnd，最终发送方发送的报文大小取cwnd以及rwnd中的较小值。</p><p>拥塞控制算法v1：</p><ol><li><p>设置ssthresh；</p></li><li><p>设置cwnd=1；</p></li><li>进入指数增长阶段，每一个RTT，将cwnd翻倍（另一种表述：每接受到一个ack，cwnd++）;如果发现2*cwnd &gt; ssthresh,令cwnd=ssthresh，进入3；如果出现网络拥堵（报文超时），那么将ssthresh = cwnd/2（至少为2）,然后进入1；</li><li>进入加性增阶段，每一个RTT,cwnd++；如果出现网络拥堵（报文超时），那么将ssthresh = cwnd/2（至少为2）,然后进入1；</li></ol><p>算法v1存在一些问题：很多时候我们很难及时察觉出网络的阻塞。为此，我们引入<strong>快重传</strong>以及<strong>快恢复</strong>方法：</p><ol><li>快重传：如果收到某一个报文的连续3次ack，那么重传对应序号报文；</li><li>快恢复：如果收到某一个报文的连续3次ack，那么设置ssthresh = cwnd/2,cwnd=ssthresh</li></ol><h3 id="一些细节问题"><a href="#一些细节问题" class="headerlink" title="一些细节问题"></a>一些细节问题</h3><ol><li><p>TCP 中的滑动窗口机制</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210323110057.png" alt="image-20210323110050055"></p><p>可以看出，在使用滑动窗口机制下，即使一些ack没有成功收到，也有可能不会导致重发，因为之后的ack一旦收到，之前的所有报文也都一定被收到。</p></li><li><p>流量控制中的探测</p><p>如前文所述，流量控制中的窗口大小是通过接收方的报文通知发送方的，因此，如果发送方在<strong>以为接收方没有任何缓冲区空间</strong>之后，接收方<strong>通知有新的缓冲区空间</strong>报文丢失，就会导致发送方“饥饿”。为此，发送方会在一个RTO之后尝试发送一个报文，通过接收方的ACK探测当前是否有新的缓冲区空间。</p></li><li><p>拥塞控制中的ssthresh</p><p>《图解TCP/IP》中指出，TCP通信的开始<strong>不会直接指出ssthresh</strong>的值，而是在第一次网络拥塞之后计算出。</p></li><li><p>快恢复的cwnd</p><p>《图解TCP/IP》中的说法是ssthresh+3，加3 的原因是因为收到3个重复的ACK。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>契约式设计</title>
    <link href="/2021/03/18/oop-03/"/>
    <url>/2021/03/18/oop-03/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是契约式设计"><a href="#什么是契约式设计" class="headerlink" title="什么是契约式设计"></a>什么是契约式设计</h3><p>在编写一个方法时，我们常常会在方法的入口处增加许多判断，从某种意义上来说，这就是一种最朴素的契约式设计。契约式设计（DbC）核心就是“规范与检查”。其主要由以下三个方面构成：</p><ul><li>前置条件：调用方法之前需要满足的条件</li><li>后置条件：方法顺利执行完成之后需要满足的条件</li><li>invariant：该类的实例调用任何方法时都必须为真的条件</li></ul><p>简单的逻辑关系是：用户在调用方法之前，<strong>确保其参数满足一定的条件</strong>，类负责<strong>确保用户获得其想要的结果</strong>。此处参数需要满足的条件分两种情况：</p><ol><li>创建一个类的实例。在此过程中，只需要确保前置条件满足；</li><li>调用一个已经存在的实例的方法。需要确保前置条件以及invariant同时满足。</li></ol><h3 id="DbC与继承的关系"><a href="#DbC与继承的关系" class="headerlink" title="DbC与继承的关系"></a>DbC与继承的关系</h3><blockquote><p>DbC与断言的不同？</p><p>个人认为可以通过断言实现DbC，但是两者绝对不是等同的概念。DbC是可以继承的，而断言无法继承。</p></blockquote><p>如果一个基类拥有前置条件<code>p0</code>，后置条件<code>q0</code>，那么其子类的前置条件以及后置条件应该满足什么样的性质？</p><ol><li>继承之后的前置条件只能保持不变或者弱化；</li><li>继承之后的后置条件只能不变或者增强。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>面向对象设计方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git出现empty object时的恢复方法</title>
    <link href="/2021/03/18/daily-210318/"/>
    <url>/2021/03/18/daily-210318/</url>
    
    <content type="html"><![CDATA[<p>在<code>git commit</code>时，终端出现报错：</p><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">error</span>: object file .git/objects/<span class="hljs-number">31</span>/<span class="hljs-number">65329</span>bb<span class="hljs-number">680</span>e<span class="hljs-number">30595</span>f<span class="hljs-number">242</span>b<span class="hljs-number">7</span>c<span class="hljs-number">4</span>d<span class="hljs-number">8406</span>ca<span class="hljs-number">63</span>eeab<span class="hljs-number">0</span> is empty<br><span class="hljs-attribute">fatal</span>: loose object <span class="hljs-number">3165329</span>bb<span class="hljs-number">680</span>e<span class="hljs-number">30595</span>f<span class="hljs-number">242</span>b<span class="hljs-number">7</span>c<span class="hljs-number">4</span>d<span class="hljs-number">8406</span>ca<span class="hljs-number">63</span>eeab<span class="hljs-number">0</span> (stored in .git/objects/<span class="hljs-number">31</span>/<span class="hljs-number">65329</span>bb<span class="hljs-number">680</span>e<span class="hljs-number">30595</span>f<span class="hljs-number">242</span>b<span class="hljs-number">7</span>c<span class="hljs-number">4</span>d<span class="hljs-number">8406</span>ca<span class="hljs-number">63</span>eeab<span class="hljs-number">0</span>) is corrupt<br></code></pre></td></tr></table></figure><p>查询，定位原因是虚拟机崩溃导致的<code>.git</code>目录下文件的损坏。</p></blockquote><p>解决方法如下：</p><p><a href="https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty">https://stackoverflow.com/questions/11706215/how-to-fix-git-error-object-file-is-empty</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树状数组】楼兰图腾</title>
    <link href="/2021/03/08/tj210308/"/>
    <url>/2021/03/08/tj210308/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/243/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题实际上可以看做是对数组中的每一个数，求出其左侧与右侧数字中大于或者小于其的元素个数。换而言之，需要维护为每一个元素维护好一个前缀和，但是如果使用朴素的前缀和实现，每一次更新需要线性的时间，故而不可取。</p><p>这时候，我们就要祭出<strong>树状数组</strong>这一高级的数据结构了。</p><p>简单说来，树状数组的核心点在于，将一个区间通过二进制分解，从而我们需要求解的任意区间可以变成<script type="math/tex">O(logN)</script>次查询。你可能要说，使用朴素前缀和，我们只需要常数时间就可以完成一次查询！的确，不过朴素的实现方式，需要线性的时间完成前缀和的维护，而树状数组只需要<script type="math/tex">O(logN)</script>时间即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200000</span>+<span class="hljs-number">10</span>;<br>ll c[N];<br><br>ll a[N]; <br>ll lles[N];<br>ll lmore[N];<br>ll rles[N];<br>ll rmore[N];<br><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    ll ans =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;x;x-=x&amp;-x)&#123;<br>        ans += c[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;x&lt;=N;x+=x&amp;-x)&#123;<br>        c[x] += val;<br>    &#125;    <br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <br>        lles[i] = ask(a[i]<span class="hljs-number">-1</span>);<br>        lmore[i] = ask(n)-ask(a[i]);<br>        add(a[i],<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        rles[i] = ask(a[i]<span class="hljs-number">-1</span>);<br>        rmore[i] =ask(n)- ask(a[i]);<br>        add(a[i],<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    ll v_ans = <span class="hljs-number">0</span>;<br>    ll cup_ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>        v_ans +=  lmore[i]*rmore[i];<br>        cup_ans += lles[i]*rles[i];<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;v_ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cup_ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【单调队列】滑动窗口最大值</title>
    <link href="/2021/03/01/tj210301/"/>
    <url>/2021/03/01/tj210301/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是开学以来的第一篇题解，为了保持一定的手感，除了周末，每天保证更新一篇题解。</p></blockquote><h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/75/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意十分简单，为数组的每一个固定长度的区间维护一个最大值。最为朴素的做法就是直接求解最大值，不过这样没有用上“滑动”的性质，是否可以边扫描数组，边维护数组的每一个最大值？</p><p>仔细思考，对于每一个区间中的数字，如果其右边的数字比其来的大，那么当前数字实际上一定不会在之后的大小比较中出现（当前数字一定先离开窗口），这启发我们维护一个值、ind的二元组队列，并且按照值单调减排列，这也就是传说中的<strong>单调队列</strong>。</p><p>维护单调队列的方法十分简单：</p><ol><li>在每一个区间中，丢弃所有不在当前窗口的元素；</li><li>对于每一个区间中新加入的元素，如果当前队列非空，比较其与队尾元素的大小，如果其比队尾元素大，那么丢弃队尾元素，执行2；否则执行3；</li><li>将当前的元素加入队列中。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; mono_q;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> ind)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(mono_q.size()&amp;&amp;x&gt;mono_q.back().first)&#123;<br>            mono_q.pop_back();<br>        &#125;<br>        mono_q.push_back(<span class="hljs-built_in">pair</span>(x,ind));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lhs)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(mono_q.size()&amp;&amp;mono_q.front().second&lt;lhs)mono_q.pop_front();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-comment">// init the queue </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k<span class="hljs-number">-1</span>;i++)&#123;<br>            add(nums[i],i);<br>        &#125;<br>        <br>        <span class="hljs-comment">// traverse all intervals</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lhs = <span class="hljs-number">0</span>;lhs+k<span class="hljs-number">-1</span>&lt;nums.size();lhs++)&#123;<br>            pop(lhs);<span class="hljs-comment">// pop all the elements which are out of window</span><br>            add(nums[lhs+k<span class="hljs-number">-1</span>], lhs+k<span class="hljs-number">-1</span>);<br>            ans.push_back(mono_q.front().first);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>数据结构</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【BFS】通信网络</title>
    <link href="/2021/02/20/tj210220/"/>
    <url>/2021/02/20/tj210220/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/3253/">这里是原题嗷</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求有向图中，可达以及可被达点集合是全集的点个数。判断可达性的方法有很多，例如bfs, dfs，也可以通过拓扑排序（无环图中），乃至缩点等方式。此处实现使用bfs。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N= <span class="hljs-number">1000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">10000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> tot;<br><span class="hljs-keyword">int</span> head[N], ver[M], Next[M];<br><span class="hljs-built_in">bitset</span>&lt;N&gt; vis[N];<br><span class="hljs-keyword">bool</span> bvis[N];<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; edges;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head);<br>    <span class="hljs-built_in">memset</span>(ver, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> ver);<br>    <span class="hljs-built_in">memset</span>(Next, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> Next);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    ver[++tot] = y, Next[tot] = head[x];<br>    head[x] = tot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(bvis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> bvis);<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(x);<br>    vis[x][x] = <span class="hljs-number">1</span>;<br>    bvis[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(q.size())&#123;<br>        <span class="hljs-keyword">int</span> cur = q.front();q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[cur];i;i = Next[i])&#123;<br>            <span class="hljs-keyword">if</span>(bvis[ver[i]])<span class="hljs-keyword">continue</span>;<br>            vis[x][ver[i]] = <span class="hljs-number">1</span>;<br>            bvis[ver[i]] = <span class="hljs-literal">true</span>;<br>            q.push(ver[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        edges.push_back(<span class="hljs-built_in">pair</span>(x, y));<br>    &#125;<br>    <br>    Init();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)vis[i].reset();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        Add(edges[i].first, edges[i].second);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        bfs(i);<br>    &#125;<br>    <br>    Init();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        Add(edges[i].second, edges[i].first);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        bfs(i);<br>        <span class="hljs-keyword">if</span>(vis[i].count()==n)ans++;<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>BFS</tag>
      
      <tag>反图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树的直径】网络延时</title>
    <link href="/2021/02/19/tj210219/"/>
    <url>/2021/02/19/tj210219/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/3218/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然，所求就是树的直径。求树的直径一般有两种方法，大家熟知的是通过两次bfs（或者dfs）求解的方法，此处给出使用树形DP的解法。</p><p>所谓的树直径，实际上就是求树中通过任意一个节点的最长链。为了求解过任意一个点的最长链大小，我们首先求解任意一个节点到其任意一个子树中叶节点的最长路径大小；显然，通过一个简单的DFS即可完成求解，我们不妨记<script type="math/tex">DP[x]</script>为节点<script type="math/tex">x</script>到其子树中叶节点的最大距离。</p><p>在此基础上，对于任何一个节点，过它的最长链实际上就是<script type="math/tex">max_{1\le j< i\le t\{DP[i]+edge(x,y_i)+DP[j]+edge (x, y_j)\}}</script>。</p><p>问题到这里，似乎已经解决了——首先通过一个DFS, 求解<script type="math/tex">DP[x]</script>，然后在通过一个DFS，内嵌一个双层循环，求解每一个节点的最长链，然而，这样的时间复杂度并不是一开始提到方法的线性。</p><p>实际上，在求解<script type="math/tex">DP[x]</script>时，遍历到第i的节点时，此时的<script type="math/tex">DP[x]=max_{1<j<i}\{DP[j]+edge(x,y_j)\}</script>。故而，整个求解过程只需要一次遍历，复杂度是线性的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">100000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> tot;<br><span class="hljs-keyword">int</span> head[N], ver[M], edge[M], Next[M];<br><span class="hljs-keyword">int</span> dp[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> head);<br>    <span class="hljs-built_in">memset</span>(ver, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> ver);<br>    <span class="hljs-built_in">memset</span>(edge, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> edge);<br>    <span class="hljs-built_in">memset</span>(Next, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> Next);<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> edge_val)</span></span>&#123;<br>    ver[++tot] = y, edge[tot] = edge_val , Next[tot] = head[x];<br>    head[x] = tot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    vis[x] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[x];i;i = Next[i])&#123;<br>        <span class="hljs-keyword">int</span> cur_ver = ver[i];<br>        <span class="hljs-keyword">int</span> edge_val = edge[i];<br>        <span class="hljs-keyword">if</span> (vis[cur_ver])<span class="hljs-keyword">continue</span>;<br>        Dfs(cur_ver);<br>        ans = max(ans, dp[x] + dp[cur_ver] + edge_val);<br>        dp[x] = max(dp[x], dp[cur_ver] + edge_val);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m,n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">int</span> node;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;node;<br>        Add(i+<span class="hljs-number">2</span>, node,<span class="hljs-number">1</span>);<br>        Add(node, i+<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">int</span> node;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;node;<br>        Add(m+<span class="hljs-number">1</span>+i, node, <span class="hljs-number">1</span>);<br>        Add(node, m+<span class="hljs-number">1</span>+i,<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    Dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>树</tag>
      
      <tag>树直径</tag>
      
      <tag>树形DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三角函数习题</title>
    <link href="/2021/02/18/tt/"/>
    <url>/2021/02/18/tt/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230655.png" alt="image-20210218230648349"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230721.png" alt="image-20210218230721518"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230756.png" alt="image-20210218230756540"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230828.png" alt="image-20210218230828741"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230900.png" alt="image-20210218230900138"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218230915.png" alt="image-20210218230915529"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218231006.png" alt="image-20210218231005959"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218231051.png" alt="image-20210218231051595"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218231227.png" alt="image-20210218231227496"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210218231302.png" alt="image-20210218231302820"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219221634.png" alt="image-20210219221634191"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219221751.png" alt="image-20210219221751557"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219221827.png" alt="image-20210219221826959"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219221854.png" alt="image-20210219221854191"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219221921.png" alt="image-20210219221921111"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219222002.png" alt="image-20210219221939400"></p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210219222002.png" alt="image-20210219222002314"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP中的计时</title>
    <link href="/2021/02/17/OpenMP%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6/"/>
    <url>/2021/02/17/OpenMP%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在写软渲染的过程中，为了加速渲染的效率，我使用<code>OpenMP</code>完成简单的多线程并行渲染。为了查看实际渲染的效果如何，使用<code>clock()</code>（头文件<code>time.h</code>）进行运行时间计时，输出实际渲染fps。</p><p>诡异的是，对比使用多线程前后，反而是不使用多线程的串行程序fps高！</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>你可能已经想到，问题的关键在于<code>clock()</code>的实现——它实际上计数的是所有cpu的tick数！换而言之，一定程度上，物理线程越多（参与运算的核），程序“用时”越长。显然，这是很不合理的，我们实际想要计量的时间应是现实中的绝对时间。</p><p>实际上， <code>OpenMP</code>提供了<code>omp_get_wtime()</code>接口，其返回一个<code>double</code>类型的变量，单位是秒。该函数可以完全替代<code>clock()</code>，并且在多线程下效果如旧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>并行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【BFS】最优配餐</title>
    <link href="/2021/02/17/tj210217/"/>
    <url>/2021/02/17/tj210217/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/3208/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是多源BFS的模板题。通过BFS来寻找最短路是非常基本的操作，实际上，存在多个起点时，也可以求出从某一个起点出发，到地图上某一个点的最短距离——把所有的起点入队即可。</p><blockquote><p>实现BFS的一些坑:</p><ol><li>去重；</li><li>生成状态；</li></ol></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N= <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NOT = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">int</span> ma[N][N];<br>ll dis[N][N];<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">state</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x_, y_;<br>    ll step_;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<br>    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (x&lt;n)&amp;&amp;(y&lt;n)&amp;&amp;(x&gt;=<span class="hljs-number">0</span>)&amp;&amp;(y&gt;=<span class="hljs-number">0</span>)&amp;&amp;(dis[x][y] == LONG_MAX)&amp;&amp;ma[x][y]!=NOT;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,k,d;<br>    <span class="hljs-comment">// cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;d;</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;d);<br>    <span class="hljs-built_in">memset</span>(ma,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> ma);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dis[i][j] = LONG_MAX;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">queue</span>&lt;state&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x, &amp;y);<br>        dis[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>        q.push(state&#123;x<span class="hljs-number">-1</span>, y<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;);<br>    &#125;<br>    <br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,ll&gt;hash;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;x, &amp;y,&amp;c);<br>        hash[x<span class="hljs-number">-1</span>+(y<span class="hljs-number">-1</span>)*n] +=c;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;d;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x, &amp;y);<br>        ma[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>] = NOT;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q.size())&#123;<br>        state cur = q.front();q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span> x = cur.x_ + dir[i][<span class="hljs-number">0</span>], y = cur.y_ + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (isvalid(x, y,n))&#123;<br>                dis[x][y] = cur.step_+<span class="hljs-number">1</span>;<br>                q.push(state&#123;x, y, cur.step_+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    ll ans =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:hash)&#123;<br>        <span class="hljs-keyword">int</span> pos = t.first;ll cost = t.second;<br>        <span class="hljs-keyword">int</span> x = pos%n, y = pos/n;<br>        ans += dis[x][y] * cost;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计数DP】有趣的数</title>
    <link href="/2021/02/16/tj210216/"/>
    <url>/2021/02/16/tj210216/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/3198/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个直观的想法是，如果我们知道长度为<script type="math/tex">l</script>的有趣的数的个数，是否可以知道长度为<script type="math/tex">l+1</script>的有趣的数个数？简单思考，容易发现，如果只知道<strong>有趣的数个数</strong>，是不足以完成递推的，例如题目中给出的4位有趣的数，并不是所有5位有趣的数的<strong>前缀</strong>。然而，如果我们可以枚举所有<strong>可行前缀的个数 </strong>，就可以完成递推，并且由于前缀是唯一的，故而递推结果不会重复。</p><p>哪些前缀是可行的？题目中的约束简单说来，就是第一个数字必须是2，0必须在1之前，2必须在3之后。故而：</p><ol><li>对于任意前缀，2必然存在其中；</li><li>只可能缺少1/3/1,3/0,1/0,1,3这些数字组合。</li></ol><p>故而，我们可以将前缀分为6种，除了上述的5种缺少数字的组合之外，还应该有全部数字都存在的情况。简单思考，这样的状态是合理的，满足最优子结构。为了讨论的方便起见，我们不妨将6种状态记为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>全有<br><span class="hljs-symbol">1 </span>缺<span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span>缺<span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span>缺<span class="hljs-number">13</span><br><span class="hljs-symbol">4 </span>缺<span class="hljs-number">01</span><br><span class="hljs-symbol">5 </span>缺<span class="hljs-number">013</span><br></code></pre></td></tr></table></figure><p>接下来思考状态如何转移。</p><ol><li>状态0可以通过自身（后缀为1,3）以及1、2两个状态转移（后缀为缺少的数字）；</li><li>状态1可以通过自身（后缀为2,1）以及状态3转移；</li><li>状态2可以通过自身（后缀为0，3）以及状态3,4转移；</li><li>状态3可以通过自身（后缀为0,2）以及状态5转移；</li><li>状态4可以通过自身（后缀为3）以及状态5转移；</li><li>状态5只可以通过自身转移。</li></ol><p>容易发现，上述每一个状态只依赖编号大于等于它的状态，故而可以只使用一个大小为6的数组完成状态转移。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000000</span> + <span class="hljs-number">7</span>;<br>ll dp[<span class="hljs-number">6</span>];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <br>    dp[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        dp[<span class="hljs-number">0</span>] = (<span class="hljs-number">2</span>*dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>])%MOD;<br>        dp[<span class="hljs-number">1</span>] = (dp[<span class="hljs-number">3</span>] + <span class="hljs-number">2</span>*dp[<span class="hljs-number">1</span>])%MOD;<br>        dp[<span class="hljs-number">2</span>] = (<span class="hljs-number">2</span>*dp[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">3</span>] +dp[<span class="hljs-number">4</span>])%MOD;<br>        dp[<span class="hljs-number">3</span>] = (<span class="hljs-number">2</span>*dp[<span class="hljs-number">3</span>] + dp[<span class="hljs-number">5</span>])%MOD;<br>        dp[<span class="hljs-number">4</span>] = (dp[<span class="hljs-number">4</span>] + dp[<span class="hljs-number">5</span>])%MOD;<br>        dp[<span class="hljs-number">5</span>] = (dp[<span class="hljs-number">5</span>])%MOD;<br>        <br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>计数DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性DP】机器人跳跃问题</title>
    <link href="/2021/02/15/tj210215/"/>
    <url>/2021/02/15/tj210215/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/732/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，原问题的解显然具有单调性——如果一个解比最优解大，那么其一定也是可行的，因为其在每一个点<strong>减少的更少，增加的更多</strong>。显然，本题可以使用二分判定一个解，不过该做法因为数据大小限制，不可行（在check解的过程中会溢出）。</p><p>那么，我们可以直接推出最优解吗？简单倒推，在最后一个站点，为了通过的最小能量值实际上就是该站点能量的一半（向上取整）；那么倒数第二个站点，为了通过的最小能量值就是通过当前站点并且可以通过下一个站点：<script type="math/tex">E+(E-cur_e)\ge E_{pass_next}</script>。根据该式子倒推即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">int</span> H[N];<br><span class="hljs-keyword">int</span> dp[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-built_in">memset</span>(H, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> H);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;H[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        dp[i] = (H[i]+dp[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>思维</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【差分】积木大赛</title>
    <link href="/2021/02/14/tj210214/"/>
    <url>/2021/02/14/tj210214/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/509/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到区间上加减同一值的操作，容易想到使用差分预处理。原问题变成，如何通过<code>(+1,-1)</code>的成对操作，使得数组中所有数字变成0。</p><p>一个直观的策略是，对于每一个负数，我们应该通过其之前的正数将其抵消。根据差分的定义，<script type="math/tex">\sum_{i=1}^{j}b_i = a_i</script>，而<script type="math/tex">a_i>0</script>，故而对于任何一个负数，一定可以找到一系列正数来与之抵消，我们的方法是合法的。其次，无论是哪一种方法，至少都需要将其中每一个负数变成正数，故而我们的方法是最优的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> D[N];<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-built_in">memset</span>(D, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> D);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        D[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    D[n+<span class="hljs-number">1</span>] = -a[n];<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span> (D[i]&lt;<span class="hljs-number">0</span>)ans += -D[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>思维</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【区间DP】加分二叉树</title>
    <link href="/2021/02/10/tj210210/"/>
    <url>/2021/02/10/tj210210/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/481/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果只知道一棵树的中序遍历，无法确定这一棵树的构造；不过，我们可以通过假定各个子树的根，从中序遍历中构造出一颗符合条件的树（有多少种可能实际上也可以通过动态规划求出）。</p><p>如果我们选定了一个根，其子树的最大值与该根无关，换而言之，问题具有最优子结构。自然而然的，我们应该使用一个中序遍历的区间作为状态（唯一确定一个最大值），原问题实际上就变成了一个区间DP 问题。</p><p>由于此处需要我们重构一棵树，所以保存每一个区间的最优节点，这样就可以通过dfs还原树。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">int</span> dp[N][N];<br><span class="hljs-keyword">int</span> best[N][N];<br><span class="hljs-keyword">int</span> val[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arrlen)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len =<span class="hljs-number">1</span>;len&lt;=arrlen;len++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=arrlen;i++)&#123;<br>            <span class="hljs-keyword">int</span> j = i+len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)&#123;<br>                dp[i][i] = val[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">int</span> maxv = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">int</span> root = val[k];<br>                <span class="hljs-keyword">int</span> left=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span>&gt;=i)left = dp[i][k<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">int</span> right =<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;=j)right = dp[k+<span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">int</span> tem = root + left*right;<br>                <br>                <span class="hljs-keyword">if</span>(tem&gt;maxv)&#123;<br>                    best[i][j] = k;<br>                    maxv = tem;<br>                &#125;<br>            &#125;<br>            dp[i][j] = maxv;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][arrlen];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        q.push_back(l);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> best_root = best[l][r];<br>    q.push_back(best_root);<br>    build_tree(l,best_root<span class="hljs-number">-1</span>,q);<br>    build_tree(best_root+<span class="hljs-number">1</span>,r,q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cin</span>&gt;&gt;val[i];<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;pre_order;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;solve(n)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    build_tree(<span class="hljs-number">1</span>,n,pre_order);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pre_order.size();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;pre_order[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Predictive Parse</title>
    <link href="/2021/02/10/ttt/"/>
    <url>/2021/02/10/ttt/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Predictive-Parse"><a href="#什么是Predictive-Parse" class="headerlink" title="什么是Predictive Parse"></a>什么是Predictive Parse</h3><p>通过提前看token的类型，合理推断产生式。</p><p>在CS 143课程中，我们讨论LL(1)文法。即<strong>从左到右、最左推导</strong>，每次提前看一个token的文法。</p><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p><code>T[A,a]</code>表示当前non terminal 为A,token为a，此时应该使用的推导。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="预处理——left-factor"><a href="#预处理——left-factor" class="headerlink" title="预处理——left factor"></a>预处理——left factor</h4><p>理想情况下，我们可以通过当前的non terminal以及token判断出应该采用什么样的产生式，但是如果出现如下的一些产生式，会出现无法判断的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143351.png" alt="image-20210210143351122"></p><p>对于T而言，它有两个<code>int</code>开头的产生式，无法直接判断应该使用哪一个产生式。</p><p>为了解决这样的一个问题，通过left factor的方法延迟决定：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143603.png" alt="image-20210210143603732"></p><h4 id="基于栈的Predictive-Parse算法"><a href="#基于栈的Predictive-Parse算法" class="headerlink" title="基于栈的Predictive Parse算法"></a>基于栈的Predictive Parse算法</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143745.png" alt="image-20210210143744977"></p><p>算法维护一个栈，通过Parsing Table来完成栈中元素的更新，直至某一个更新出现error或者栈为空（已经完美匹配）。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143916.png" alt="image-20210210143916660"></p><p>任意一个时刻，栈顶元素只可能有两种情况：终结符或者非终结符。</p><p>如果是一个终结符，那么直接比较该终结符是否与当前的token匹配，如果不匹配则error；反之，完成匹配，弹出栈顶。</p><blockquote><blockquote><p> 是否可能出现input stream中的token使用完，*next++出错的情况？</p></blockquote><p>为了避免这种情况出现，我们将<script type="math/tex">`作为终结符分别放入input stream以及stack中。如果input stream中token使用完，那么一定会遇到`</script>，从而避免了该情况。</p></blockquote><p>如果是一个非终结符，根据Parsing Table，如果不存在一个对应的表项，error;反之，弹出当前栈顶，将产生式放入栈中。</p><h3 id="Parsing-Table的产生"><a href="#Parsing-Table的产生" class="headerlink" title="Parsing Table的产生"></a>Parsing Table的产生</h3><p>Predictve Parse算法的实现需要Parsing Table，下面从First Set,Follow Set的定义开始，分析如何通过他们来构造一个Parsing Table。</p><h4 id="基本观察"><a href="#基本观察" class="headerlink" title="基本观察"></a>基本观察</h4><p>Parsing Table应该满足什么样的性质？换而言之，我们是如何根据当前的非终结符以及下一个token的值，确定我们应该采用什么样的产生式的？对于<script type="math/tex">T[A,a]</script>，如果<script type="math/tex">A\to \alpha</script>，我们有以下的两个观察：</p><p>首先，如果<script type="math/tex">\alpha \to^* t\beta</script>，那么显然<script type="math/tex">T[A, t]=\alpha</script>（此处我们不讨论是否可能存在不止一个<script type="math/tex">\alpha</script>满足该情况）；如果<script type="math/tex">\alpha \to \epsilon\ \& S\to ^* \beta At\sigma</script>，那么也应该<script type="math/tex">T[A,t]=\alpha</script>，因为哦我们可以忽略当前的<script type="math/tex">A</script>，最终也可以完成匹配。</p><p>对于第一种情况，我们称<script type="math/tex">t\in First(\alpha)</script>；对于第二种情况，我们称<script type="math/tex">t\in Follow(A)</script>。尽管我们现在还没有给First Set以及Follow Set一个具体的定义，但是我们可以大概猜到他们的含义：前者表示出现在其句子的最左的终结符；后者表示存在一个句型使得出现在其后的终结符。</p><h4 id="First-Set"><a href="#First-Set" class="headerlink" title="First Set"></a>First Set</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150021.png" alt="image-20210210150021156"></p><p>简单说来，就是<script type="math/tex">X</script>的所有句子中最左边的终结符或者<script type="math/tex">\epsilon</script>。值得注意的是，终结符也是存在First Set的。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150235.png" alt="image-20210210150235704"></p><p>显然，该算法实际上是递归定义的，递归基就是终结符。</p><h4 id="Follow-Set"><a href="#Follow-Set" class="headerlink" title="Follow Set"></a>Follow Set</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150609.png" alt="image-20210210150609810"></p><blockquote><p>简单说来，就是所有存在非终结符<script type="math/tex">X</script>的句型中，其后的终结符。</p></blockquote><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150748.png" alt="image-20210210150748004"></p><p>第一个性质是显然的，因为根据定义，<script type="math/tex">A</script>之后的所有终结符在Follow(A)中；</p><p>第二个性质有一点点抽象，简单说来，由于B是该产生式中的最后一个元素，故而对于所有有X的句型，都可以将其替换成xxB，故而其后的终结符也一定在Follow(B)中；</p><p>第三个性质是根据我们的Predictive Parse的算法架构，应该加上这样一个限制。</p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210151101.png" alt="image-20210210151101392"></p><p>需要注意的是此处的第三条规则，根据First Set的定义以及上一节中的第二条性质，我们得出了该结论。</p><h4 id="根据First-Set以及Follow-Set生成Parsing-Table"><a href="#根据First-Set以及Follow-Set生成Parsing-Table" class="headerlink" title="根据First Set以及Follow Set生成Parsing Table"></a>根据First Set以及Follow Set生成Parsing Table</h4><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><p>实际上就是我们在介绍Firset Set以及Follow Set时提出的方案：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210152257.png" alt="image-20210210152257231"></p><blockquote><p><strong>一些细节</strong></p><p>对于<script type="math/tex">A\to\alpha</script>，此处的<script type="math/tex">\alpha</script>实际上可能是一个非终结符与终结符的混合，我们需要根据First Set来判断使用哪一个First Set；</p></blockquote><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>前文讨论过，如果出现了一个表项对应多个产生式，应该如何解决？实际上，这就说明该语言实际上无法通过LL(1)文法表达。</p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【复习】正则化</title>
    <link href="/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><h4 id="什么是过拟合与欠拟合"><a href="#什么是过拟合与欠拟合" class="headerlink" title="什么是过拟合与欠拟合"></a>什么是过拟合与欠拟合</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210100655.png" alt="image-20210210100648682"></p><p>训练过程中，如果训练集中的特征数量过多，很有可能导致训练出的模型在训练集上的表现过好，我们称之为过拟合。这本来是一件美好的事情，然而此时的拟合情况优秀实际上是难以<strong>泛化</strong>的，我们需要极力避免这样的情况出现。</p><p>相反地，如果一个模型在训练集上拟合水平过低，我们称之为欠拟合。欠拟合的情况可以通过增加数据量来解决。</p><h4 id="如何避免过拟合"><a href="#如何避免过拟合" class="headerlink" title="如何避免过拟合"></a>如何避免过拟合</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210101123.png" alt="image-20210210101123699"></p><p>既然过拟合的主要原因是特征数量过多，模型学习到了不应该学习的内容，那么一个可行的解决措施就是<strong>特征工程</strong>——减少特征数量或者选择一些具有代表性的特征；其次，我们也可以通过正则化的方式削弱特征的作用，避免过拟合。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>习题解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OnComponentBeginOverlap签名参数问题</title>
    <link href="/2021/02/10/UE4-210210/"/>
    <url>/2021/02/10/UE4-210210/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>UE4.25版本中，为事件<code>OnComponentBeginOverlap</code>添加委托，对应签名为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_SixParams( FComponentBeginOverlapSignature, UPrimitiveComponent, OnComponentBeginOverlap, UPrimitiveComponent*, OverlappedComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, int32, OtherBodyIndex, <span class="hljs-keyword">bool</span>, bFromSweep, <span class="hljs-keyword">const</span> FHitResult &amp;, SweepResult);<br></code></pre></td></tr></table></figure><p>如果此处直接复制签名中的参数，无法通过编译。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>去掉第一个参数（OnComponentBeginOverlap）即可。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>UE4中为事件添加委托的一般流程：确定委托签名 -&gt; 编写回调函数 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术细节</tag>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【思维】池塘钓鱼</title>
    <link href="/2021/02/09/tj210209/"/>
    <url>/2021/02/09/tj210209/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/1264/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然，一个最优的方案一定是依次在若干个鱼塘钓鱼，没有往返路途（否则，返回时所钓的鱼可以在第一次位于该鱼塘时钓出）。问题在与，如何求出最优的一个鱼塘序列？确定了一个鱼塘序列之后，应该在每一个鱼塘钓多少鱼？</p><p>确定在哪些鱼塘钓鱼是困难的，但是我们可以<script type="math/tex">O(N)</script>枚举可能的鱼塘。确定了鱼塘序列之后，类比多路归并的思路，显然我们可以在<script type="math/tex">O(log N)</script>复杂度内确定在哪一个池塘钓鱼（求解的值并不是时间连续的，但是显然可以排列成一个合法的序列）。</p><p>最终的时间复杂度是<script type="math/tex">O(N*T*logN)</script>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> sub;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;n1, <span class="hljs-keyword">const</span> node &amp; n2)&#123;<br>        <span class="hljs-keyword">return</span> n1.val&lt;n2.val;<br>    &#125;<br>&#125;;<br><br>node d[N];<br><span class="hljs-keyword">int</span> road_time [N];<br><span class="hljs-built_in">priority_queue</span>&lt;node, <span class="hljs-built_in">vector</span>&lt;node&gt; &gt;pq;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> tot_time)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cur_time = tot_time;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr_len;i++)&#123;<br>        cur_time = tot_time;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cur_time -= road_time[j];<br>            <span class="hljs-keyword">if</span>(cur_time&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(pq.size())pq.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            pq.push(d[j]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> tem_ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pq.size() &amp;&amp; cur_time &gt;<span class="hljs-number">0</span>)&#123;<br>            cur_time --;<br>            node topnode = pq.top();pq.pop();<br>            tem_ans += topnode.val;<br>            <span class="hljs-keyword">if</span>(topnode.val-topnode.sub&gt;<span class="hljs-number">0</span>)&#123;<br>                pq.push(node&#123;topnode.val-topnode.sub, topnode.sub&#125;);<br>            &#125;<br>        &#125;<br>        ans = max(ans, tem_ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;d[i].val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;d[i].sub;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;road_time[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> tot_time;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;tot_time;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;solve(n,tot_time)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【二分】借教室</title>
    <link href="/2021/02/06/tj210206/"/>
    <url>/2021/02/06/tj210206/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/505/">Acwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始没有读清题目，以为遇到了一个不满足的人之后会忽略他，继续处理，所以想的复杂了一点。</p><p>我们假设实际可以满足的人数为n，处理的人数为x。显然，如果x&gt;n，那么一定不满足；换而言之，可以通过二分来查找最小的一个满足条件的解（也就是n）。</p><p>二分本身为对数复杂度，考虑到本题的数据量，二分中判断的复杂度应该是线性的。问题的判定是对一个数组进行x次的区间减法，之后的区间中是否存在负值。如果采用朴素的方法，那么每一次区间减法需要线性复杂度，整体需要平方复杂度，显然 不符合要求。这里需要使用<strong>差分</strong>的方法，将区间减法变为点减法，时间复杂度也就变为线性复杂度。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>ll S[N];<br>ll A[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> l;<br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-keyword">int</span> dat;<br>&#125; interval[N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(S, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(S));<br>    S[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;i++)&#123;<br>        S[i] = A[i]-A[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=mid;i++)&#123;<br>        S[interval[i].l] -= interval[i].dat;<br>        S[interval[i].r+<span class="hljs-number">1</span>] +=  interval[i].dat;<br>    &#125;<br>    <br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        res += S[i];<br>        <span class="hljs-keyword">if</span> (res&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;                          <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> interval_len)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = interval_len + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(is_valid(mid, arr_len))&#123;<br>            r = mid; <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (l==interval_len+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;A[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;interval[i].dat&gt;&gt;interval[i].l&gt;&gt;interval[i].r;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = solve(n,m);<br>    <span class="hljs-keyword">if</span>(res)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;-1\n&quot;</span>&lt;&lt;res&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;0\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bison 简单上手</title>
    <link href="/2021/02/06/Bison-Tutorial/"/>
    <url>/2021/02/06/Bison-Tutorial/</url>
    
    <content type="html"><![CDATA[<p> Bison的文档十分详细，也可以说是冗长，故而此处对其中的一些核心机制做一个简单的总结。</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>可以像flex中一样为rules添加Action，在规则之后的一个block中定义语法。</p><p>bison中提供了机制实现semantic value的计算。使用$$$$可以访问起始符的值（规则左边的non terminal），<code>$n</code>可以访问第n个non terminal的值，此处n从1开始。如果n小于等于0，则使用当前parse stack上的非终结符值（risky）。</p><h3 id="Bison-Decalrations"><a href="#Bison-Decalrations" class="headerlink" title="Bison Decalrations"></a>Bison Decalrations</h3><h4 id="Token-Kind-Names"><a href="#Token-Kind-Names" class="headerlink" title="Token Kind Names"></a>Token Kind Names</h4><p>对于terminal的声明。</p><h4 id="Operator-Precedence"><a href="#Operator-Precedence" class="headerlink" title="Operator Precedence"></a>Operator Precedence</h4><p>对于优先级的声明。</p><p>使用%left 表示优先左结合，%right同理。</p><h4 id="Nonterminal-Symbols"><a href="#Nonterminal-Symbols" class="headerlink" title="Nonterminal Symbols"></a>Nonterminal Symbols</h4>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【二分/前缀和】聪明的质检员</title>
    <link href="/2021/02/05/tj210205/"/>
    <url>/2021/02/05/tj210205/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/501/">Acwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>容易发现，当<script type="math/tex">W$$$增加时， $$$Y</script>单调不增。直接二分即可。</p><p>一个需要注意的细节是，此处要求的是<script type="math/tex">|Y-S|</script>的最小值。由于二次函数的特殊性 ，实际上我们不需要直接考虑<script type="math/tex">|Y-S|</script>这样一个目标函数（单峰，直接求解需要使用三分法），我们只需要求出<script type="math/tex">S</script>左侧距离其最近的一个点即可，而其右侧距离最小的点一定是所求点的下一个点。</p><p>另一个需要注意的细节是，为了快速求解区间和，需要预处理前缀和。</p><h3 id="题外话-整数域二分的实现"><a href="#题外话-整数域二分的实现" class="headerlink" title="题外话-整数域二分的实现"></a>题外话-整数域二分的实现</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>此处使用的是 lyd书中给出的实现方法，其主要特点为：</p><ol><li>有两种不同的实现二分的形式（分别为求一个数字的后继以及求一个数字的前驱）；</li><li>二分结束时，<script type="math/tex">l</script>若在界内，则一定是解；反之，说明无解。</li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>以下假定使用数组a[1-N]保存单调序列，并且我们使用<strong>满足条件</strong>来完成一定程度的抽象。我们假定，如果一个元素<strong>满足条件</strong>，那么其后继一定也<strong>满足条件</strong>。</p><p>如果是求一个元素的后继（在一个单调的序列中，<strong>满足条件</strong>的最小的一个元素）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* find the next value</span><br><span class="hljs-comment"> * return: -1 means no solution, otherwise the solution</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br><span class="hljs-keyword">int</span> l, r;<br>    l = <span class="hljs-number">1</span>;<br>    r = arr_len; <span class="hljs-comment">// arr_len will never be taken.If l ends at arr_len, there is no such value</span><br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (satisify(a[mid]))&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l == arr_len)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a[l];<br>&#125;<br></code></pre></td></tr></table></figure><p>对以上代码做一个简单的讲解。</p><p><code>line 8</code>: 由于<script type="math/tex">(l+r)>>1</script>永远不会取值<script type="math/tex">r</script>，故而将<script type="math/tex">r</script>设置为一个越界值，如果发现<script type="math/tex">l</script>停留在该值上，说明无解。</p><p><code>line 12</code>:  由于希望找到满足性质的最小元素，并且当前元素满足性质，故而我们舍弃右半区间。</p><p>求一个元素的前驱是类似的，但是需要注意求$mid$时的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* find the previous value</span><br><span class="hljs-comment"> * return: -1 means no solution, otherwise the solution</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br><span class="hljs-keyword">int</span> l, r;<br>    l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0  will never be taken.If l ends at 0, there is no such value</span><br>    r = arr_len<span class="hljs-number">-1</span>; <br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (satisify(a[mid]))&#123;<br>            l = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a[l];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2000000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-comment">/* all starts form index 1 */</span><br>ll w[N];<br>ll v[N];<br>ll sum[N]; <br>ll cnt[N];<br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; interval[N];<br><br><span class="hljs-function">ll <span class="hljs-title">caculate_Y</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W,<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> interval_len)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cnt));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=arr_len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(w[i]&gt;=W)&#123;<br>            cnt[i]=<span class="hljs-number">1</span>;<br>            sum[i] += v[i];<br>        &#125;<br>        sum[i] += sum[i<span class="hljs-number">-1</span>];<br>        cnt[i] += cnt[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=interval_len;i++)&#123;<br>        ll sum_of_yi = sum[interval[i].second]-sum[interval[i].first<span class="hljs-number">-1</span>];<br>        ll sum_of_cnt = cnt[interval[i].second] - cnt[interval[i].first<span class="hljs-number">-1</span>];<br>        ans += sum_of_yi * sum_of_cnt;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll arr_len, interval_len, S;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;arr_len&gt;&gt;interval_len&gt;&gt;S;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=arr_len;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=interval_len;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;interval[i].first&gt;&gt;interval[i].second;<br>    &#125;<br>    <br>    ll ans = LONG_LONG_MAX;<br>    <br>    <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r =<span class="hljs-number">1000000</span>+<span class="hljs-number">10</span>, mid;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        ll res = caculate_Y(mid, arr_len, interval_len);<br>        <span class="hljs-keyword">if</span>(res &gt;= S)l = mid;<br>        <span class="hljs-keyword">else</span>&#123;<br>            r = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    ans = min(ans, min(<span class="hljs-built_in">abs</span>(caculate_Y(l, arr_len, interval_len)-S),<span class="hljs-built_in">abs</span>(caculate_Y(l+<span class="hljs-number">1</span>, arr_len, interval_len)-S)));<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【贪心】耍杂技的牛</title>
    <link href="/2021/02/04/tj210204/"/>
    <url>/2021/02/04/tj210204/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/127/">题目链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>邻项交换模板题。</p><p>考虑两个相邻项，不妨记为<script type="math/tex">w_i</script>以及<script type="math/tex">w_{i+1}</script>，证明如果<script type="math/tex">w_i+s_i>w_{i+1}+s_{i+1}</script>，那么交换这两项可以使得危险度最大值更小。</p><blockquote><p>证明：</p><p>不妨记<script type="math/tex">presum = \sum_{i=1}^{i-1}w_i</script>。交换之前，第<script type="math/tex">i</script>项对应的危险度为<script type="math/tex">presum-s_i</script>，第<script type="math/tex">i+1</script>项的危险度为<script type="math/tex">presum+w_i-s_{i+1}</script>，局部的最大危险度为<script type="math/tex">presum+max(-s_i, w_i-s_{i+1})</script>；交换 之后，第<script type="math/tex">i</script>项对应的危险度为<script type="math/tex">presum+w_{i+1}-s_i</script>，第<script type="math/tex">i+1</script>项对应的危险度为<script type="math/tex">presum-s_{i+1}</script>，局部的最大值为<script type="math/tex">presum+max(-s_{i+1},w_{i+1}-s_i)</script>。由于<script type="math/tex">w_i>0</script>，可知<script type="math/tex">-s_i<w_{i+1}-s_i,-s_{i+1}<w_i-s_{i+1}</script>，故而当<script type="math/tex">w_i+s_i>w_{i+1}+s_{i+1}</script>时，  有交换之前的最大危险度大于交换之后的最大危险度。</p></blockquote><p>由此，以<script type="math/tex">w+s</script>进行排序，排序之后序列中的最大危险度最小。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ll w;<br>    ll s;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp; n1, <span class="hljs-keyword">const</span> node &amp;n2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (n1.w+n1.s)&gt;(n2.w+n2.s);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000</span> + <span class="hljs-number">10</span>;<br>node a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n ;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    ll sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i].w&gt;&gt;a[i].s;<br>        sum += a[i].w;<br>    &#125;<br>    <br>    sort(a, a+n, cmp);<br>    ll ans = <span class="hljs-number">-999999999</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        ans = max(sum-a[i].w-a[i].s, ans);<br>        sum -= a[i].w;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>贪心</tag>
      
      <tag>邻项交换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和】糖果均摊</title>
    <link href="/2021/02/03/model-jfvp/"/>
    <url>/2021/02/03/model-jfvp/</url>
    
    <content type="html"><![CDATA[<h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p><a href="https://www.acwing.com/problem/content/124/">题目链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有两种思考方式：</p><h5 id="通过均分纸牌问题迁移"><a href="#通过均分纸牌问题迁移" class="headerlink" title="通过均分纸牌问题迁移"></a>通过均分纸牌问题迁移</h5><p><a href="https://www.acwing.com/problem/content/1538/">均分纸牌问题</a>是本题的一个简化版，非环情况。对于非环情况，容易发现，最值就是$\sum<em>{i=1}^{M}|i\times avg-G[i]|$，其中$avg$是所有数的均值（下同），$G[i]$是前缀和。为了简化问题，我们将原先的前缀和$G[i]$预处理为$S[i]=G[i]-i\times avg$（也就是每一个数字减去均值），那么最小值就是$\sum</em>{i=1}^{M}|S[i]|$。</p><p>对于环形情况，一个自然的想法是通过断开环来构造一个最值情况。问题变成是否存在两个点，他们之间没有发生纸牌的传递，<strong>这里的证明我没有想清楚，但是可以猜测，必然存在一组最优解满足该约束</strong>。那么，我们便可以将环从这样的两个点之间断开，从而原问题变成了一个均分纸牌问题。</p><p>当我们从$k$处断开环时，断开之后的环如下（其中$A[i]$是原先的数字减去$avg$之后的值）：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210203205600.JPG" alt="IMG_0214"></p><p>显然，$S[M]=0$，故而所求的最值就是$\sum_{i=1}^{M}|S[i]-S[k]|$，显然最值当$S[k]$为中位数时取得。</p><h5 id="解方程组"><a href="#解方程组" class="headerlink" title="解方程组"></a>解方程组</h5><p>该题解来自于<a href="https://blog.csdn.net/clover_hxy/article/details/71078183">csdn</a>:</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210203205950.png" alt="image-20210203205950654"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>ll sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i];<br>        sum[i]+=sum[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    ll ave = sum[n]/n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        sum[i]-=i*ave;<br>    &#125;<br>    <br>    nth_element(sum+<span class="hljs-number">1</span>, sum+<span class="hljs-number">1</span>+n/<span class="hljs-number">2</span>, sum+n+<span class="hljs-number">1</span>);<br>    ll res =<span class="hljs-number">0</span>;<br>    ll mid = sum[<span class="hljs-number">1</span>+n/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        res += <span class="hljs-built_in">abs</span>(mid-sum[i]);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和/TRIE】牛异或</title>
    <link href="/2021/02/02/tj-210202-2/"/>
    <url>/2021/02/02/tj-210202-2/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的思路是，使用异或前缀和（异或前缀也具有普通前缀和的性质）枚举所有可能的区间，找出异或值最大的一个区间。显然，在1e5的数据量下，朴素算法会超时。</p><p>如果能够联想到<strong>最大异或对</strong>这道题目，不难发现本题实际上可以转化为该题。</p><p>经过前缀和预处理之后，显然本题就是求出一对最大异或对，不过有以下的一些corner case:</p><ol><li>应该在线处理。如果读取所有的输出再处理，那么需要额外的数据结构来处理<strong>最短区间</strong>这样一个限制；如果在线处理，那么始终保持当前trie中的索引（end标记）是最新的，必然可以保证最短区间这一性质；</li><li>如何判断区间。与普通的前缀和类似，应该从1开始保存（下标0保存0）。这样一来，只有一个元素与有多个元素不需要额外判断（相当于加了一个固定的边界）。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/* Trie */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">1e5</span>*<span class="hljs-number">22</span>;<br><span class="hljs-keyword">int</span> trie[SIZE][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> en[SIZE];<br><span class="hljs-keyword">int</span> tot;<br><span class="hljs-keyword">int</span> STRLEN = <span class="hljs-number">21</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    tot = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(trie,<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(trie));<br>    <span class="hljs-built_in">memset</span>(en, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(en));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (val&gt;&gt;(STRLEN<span class="hljs-number">-1</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val]==<span class="hljs-number">0</span>)trie[p][cur_val]=++tot;<br>        p = trie[p][cur_val];<br>    &#125;<br>    <br>    en[p]=index;<br>&#125;<br><br><br><span class="hljs-comment">/*ds*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_max_xor_index</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (num&gt;&gt;(<span class="hljs-number">20</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val^<span class="hljs-number">1</span>])&#123;<br>            p=trie[p][cur_val^<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p=trie[p][cur_val];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> en[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    init();<br>    <br>    trie_insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">int</span> maxv = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> l=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> r=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i];<br>        sum[i]^=sum[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">int</span> tem_index = get_max_xor_index(sum[i]);<br>        <span class="hljs-keyword">if</span>((sum[i]^sum[tem_index])&gt;maxv)&#123;<br>            maxv = sum[i]^sum[tem_index];<br>            l = tem_index+<span class="hljs-number">1</span>;<br>            r = i;<br>        &#125;<br>        trie_insert(sum[i], i);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;maxv&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和】k倍区间</title>
    <link href="/2021/02/02/tj-210202/"/>
    <url>/2021/02/02/tj-210202/</url>
    
    <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先观察数据范围，1e5，枚举区间显然会tle。<br>观察性质，如果一个区间满足k倍区间性质，那么该有前缀和<code>sum[l-1]%k=sum[r]%k</code>。显然，只需要使用一哈希函数记录每一个键值出现的次数，便可以计算（例如%k=3一共有三个端点，那么一共有2+1=3种可能的区间），遍历一遍前缀和即可。<br>需要注意的是，sum[0]本身也应该参与这个计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span>+<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt[N];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i+<span class="hljs-number">1</span>];<br>        sum[i+<span class="hljs-number">1</span>] += sum[i];<br>    &#125;<br><br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">int</span> mod_res = sum[i]%k;<br>        ans += cnt[mod_res];<br>        cnt[sum[i]%k]++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA2 实验指北</title>
    <link href="/2021/02/01/CS143PA2/"/>
    <url>/2021/02/01/CS143PA2/</url>
    
    <content type="html"><![CDATA[<p>cs143 在线课程的第二次实验，目标为实现cool语言的lexer。整个实验的核心就是通过flex自动化生成lexer，所以我的主要时间都在熟悉flex语法以及使用正则表达式编写规则上。本次实验开始，官方提供了auto grading测试脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210201100339.png" alt="PA2分数"></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="flex熟悉与使用"><a href="#flex熟悉与使用" class="headerlink" title="flex熟悉与使用"></a>flex熟悉与使用</h4><blockquote><p><code>flex</code> is a tool for generating <em>scanners</em>. A scanner is a program which recognizes lexical patterns in text. The <code>flex</code> program reads the given input files, or its standard input if no file names are given, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and C code, called <em>rules</em>. <code>flex</code> generates as output a C source file, ‘<code>lex.yy.c</code>’ by default, which defines a routine <code>yylex()</code>. This file can be compiled and linked with the flex runtime library to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding C code.</p></blockquote><p>flex通过用户编写的规则（包括正则表达式（pattern）以及对应的动作(action)），自动生成一个对应的lexer。</p><p>flex的一些基本规则在实验指南中都有提及，如果想要进一步深入了解flex，个人建议通过<a href="https://garudaxc.github.io/BisonTest/#Introduction">官方文档</a>。</p><h4 id="cool的token-class"><a href="#cool的token-class" class="headerlink" title="cool的token class"></a>cool的token class</h4><p>cool语言主要有以下的几类token class:</p><ol><li>Integers</li><li>Identifiers</li><li>Special Notations</li><li>Strings</li><li>Comments</li><li>Keywords</li><li>White Spaces</li></ol><p>下面逐个介绍如何为其编写flex规则，对于每一个token class，我都从<strong>匹配、semantic value获取</strong>两个方面介绍。</p><h5 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h5><p>在lexical语境下，cool定义的Integers就是0-9数字组成的字符串，故而使用<code>[0-9]+</code>即可匹配。</p><p>在词法分析阶段，不需要对整数的大小做出判断；换而言之 ，此时我们只需要保存Integer对应的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cool_yylval.symbol = inttable.add_string(yytext);<br><span class="hljs-keyword">return</span> INT_CONST;<br></code></pre></td></tr></table></figure><p>这里的cool_yylval是在cool_parse.h中定义的一个自定义数据类型，其保存了在之后阶段中会使用的一系列语义信息，例如symbol中保存了symbol相关的语义值（cool_yylval.symbol的类型就是一个Symbol）；boolean中保存了布尔相关的语义值等等。</p><p>此处的<code>return INT_CONST</code>会在run time嵌入到yylex()中（参见flex文档），其返回值含义是当前token class的编号（各个值的枚举参见cool_parse.h）。</p><h5 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h5><p>cool中的identifiers分为Type Identifiers（例如String, Int）以及Object Identifiers（例如count_down）。</p><blockquote><p><strong>Trap！</strong></p><p>由于后文介绍的Keywords是大小写不敏感的（除了true以及false），故而在编写规则时，应该将Identifiers放到Keywords之后。</p></blockquote><p>两者的匹配与semantic值的设置如出一辙：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">TYPE_ID         [A-Z][A-Za-z0<span class="hljs-number">-9</span>_]*<br>OBJ_ID          [a-z][A-Za-z0<span class="hljs-number">-9</span>_]*<br><br>&#123;TYPE_ID&#125;  &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> TYPEID;<br>           &#125;<br><br>&#123;OBJ_ID&#125;   &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> OBJECTID;<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="Special-Notations"><a href="#Special-Notations" class="headerlink" title="Special Notations"></a>Special Notations</h5><p>Special Notations包括单元、多元运算符、各种基本符号等。对于多元运算符，cool_parse.h中定义了其token_class对应的值，对于单元符号，其自身的ASCII值就是token class对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* </span><br><span class="hljs-comment">  * The single character operators</span><br><span class="hljs-comment">  */</span><br><br>\- |<br>\+ | <br>\~ | <br>\* | <br>\/ | <br>\&lt; | <br>\= | <br>\: | <br>\; | <br>\@ | <br>\&#123; | <br>\&#125; | <br>\, | <br>\. | <br>\( | <br>\) <span class="hljs-keyword">return</span> yytext[<span class="hljs-number">0</span>];<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  The multiple-character operators.</span><br><span class="hljs-comment">  */</span><br><br>&#123;DARROW&#125;&#123; <span class="hljs-keyword">return</span> (DARROW); &#125;<br><br>&#123;ASSIGN&#125;    &#123;<span class="hljs-keyword">return</span> (ASSIGN);&#125;<br><br>&#123;LE&#125;        &#123; <span class="hljs-keyword">return</span> (LE);&#125;<br></code></pre></td></tr></table></figure><h5 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h5><p>字符串的处理包括匹配以及错误处理，较为复杂。</p><p>当遇到一个<code>&quot;</code>时，开始解析字符串，直至出现错误或遇到下一个<code>&quot;</code>完成字符串的封闭。</p><p>在解析过程中，需要注意一些特殊情况：</p><ol><li><p>转义字符。所有以<code>\</code>开头的字符都是转义字符，其解释为<code>\</code>之后的字符；</p><blockquote><p><strong>Trap!</strong></p><p>这里的“所有……”不包括以下字符：</p><p>\n ,\t,\b,\f以及\0</p></blockquote></li><li><p>escaped newline。在一个字符串中，不可以直接连接两行，需要在一行末尾添加<code>\</code>；</p></li><li><p>null字符。如果解析过程中遇到了<code>\0</code>字符，则认为出错；</p></li><li><p>字符串过长。cool中设定字符串至多1024（不包括<code>\0</code>）</p></li></ol><p>此处指出了字符串处理成过程中的几种错误处理：</p><ol><li>中途换行。该错误视为用户没有添加右引号，所以应该从下一行开始解析；</li><li>包含<code>\0</code>字符。该错误视作该字符串无效，故而应该从下一行（如果还存在错误1）或从右引号下一个字符开始解析；</li><li>包含eof。该错误同样视作该字符串无效，处理方式同2；</li><li>字符串过长。处理方式同2。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  String constants (C syntax)</span><br><span class="hljs-comment">  *  Escape sequence \c is accepted for all characters c. Except for </span><br><span class="hljs-comment">  *  \n \t \b \f, the result is c.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  */</span><br><br>\<span class="hljs-string">&quot; &#123;</span><br><span class="hljs-string">    BEGIN(string);</span><br><span class="hljs-string">    str_len = 0;</span><br><span class="hljs-string">    string_buf_ptr = string_buf;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\&quot; &#123;</span><br><span class="hljs-string">            BEGIN(0);</span><br><span class="hljs-string">            *string_buf_ptr = &#x27;\0&#x27;;</span><br><span class="hljs-string">            cool_yylval.symbol = stringtable.add_string(string_buf);</span><br><span class="hljs-string">            return STR_CONST;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\n &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>Unterminated <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(0); /* start from the new line */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\0 &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;&lt;&lt;EOF&gt;&gt; &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>EOF in <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\n |</span><br><span class="hljs-string">&lt;string&gt;\\b |</span><br><span class="hljs-string">&lt;string&gt;\\t |</span><br><span class="hljs-string">&lt;string&gt;\\f &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string">              *string_buf_ptr++ = get_sp_char(yytext[1]);</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\(.|\n) &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">              *string_buf_ptr++ = yytext[1];</span><br><span class="hljs-string">              if (yytext[1]==&#x27;\n&#x27;)&#123;</span><br><span class="hljs-string">                ++curr_lineno;</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">              if (yytext[1]==&#x27;\0&#x27;)&#123;</span><br><span class="hljs-string">                cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">                BEGIN(invalid_string);</span><br><span class="hljs-string">                return (ERROR);</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;[^\\\n\0\&quot;]+ &#123;</span><br><span class="hljs-string">                      char *yyptr = yytext;</span><br><span class="hljs-string">                      while(*yyptr)&#123;</span><br><span class="hljs-string">                        str_len ++;</span><br><span class="hljs-string">                        CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">                        *string_buf_ptr++ = *yyptr++;</span><br><span class="hljs-string">                      &#125;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;invalid_string&gt;[^\n&quot;</span>]*(\n|\<span class="hljs-string">&quot;) BEGIN(0); /* jump to the end of the string */</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>注释分为两种，单行注释（以<code>--</code>开头）以及多行嵌套注释（以<code>(*</code>开头）。</p><p>前者较为简单，后者需要考虑嵌套的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;--&quot;</span>[^\n]* <span class="hljs-comment">/* single line comment, don&#x27;t eat up the \n*/</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  Nested comments</span><br><span class="hljs-comment">  */</span><br><br><br>&#123;LEFTCOMMENT&#125; &#123;<br>              BEGIN(comment);<br>              comment_num =<span class="hljs-number">1</span>;<br>              &#125;<br><br>&lt;comment&gt;&#123;LEFTCOMMENT&#125; &#123;comment_num++;&#125;<br><br>&lt;comment&gt;[^(*\n]+  <span class="hljs-comment">/* eat up all the characters which are not * or newline */</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;(&quot;</span>+[^*]* <span class="hljs-comment">/* eat up all the ( which are not nested (*/</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;*&quot;</span>+[^*)\n]* <span class="hljs-comment">/* eat up all the * which are not follwed by *) or new line*/</span><br><br>&lt;comment&gt;&lt;&lt;EOF&gt;&gt; &#123;<br>            cool_yylval.error_msg = <span class="hljs-string">&quot;EOF in comment&quot;</span>;<br>            BEGIN(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> (ERROR);<br>            &#125;<br><br>&lt;comment&gt;\n ++curr_lineno;<br><br>&lt;comment&gt;&#123;RIGHTCOMMENT&#125; &#123;<br>                          comment_num--;<br>                          <span class="hljs-keyword">if</span> (comment_num ==<span class="hljs-number">0</span>)&#123;<br>                              BEGIN(<span class="hljs-number">0</span>);<br>                          &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure><h5 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h5><p>注意大小写即可，此处按下不表。</p><h5 id="White-Spaces"><a href="#White-Spaces" class="headerlink" title="White Spaces"></a>White Spaces</h5><p>需要将换行符单独考虑，维护代码行数，此处按下不表。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>PA2并不困难，只是较为繁琐（例如String以及Comment中状态机的设计），实验整体耗时大约8小时。</p><p>学习到的知识点：</p><ol><li>lexer工作基本流程；</li><li>flex如何使用，一些较为进阶的小技巧。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【区间DP】Polygon</title>
    <link href="/2021/01/29/tj-211129/"/>
    <url>/2021/01/29/tj-211129/</url>
    
    <content type="html"><![CDATA[<h3 id="题面链接"><a href="#题面链接" class="headerlink" title="题面链接"></a>题面链接</h3><p><a href="https://www.acwing.com/problem/content/description/285/">https://www.acwing.com/problem/content/description/285/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目给出一个多边形，边为运算符，顶点为数值，所求为删去一条边之后，通过不断合并边可以获得的最大值。</p><p>乍一看，删去哪一条边获取最大值是未知的，需要枚举每一条边。</p><p>枚举之后，原来的多边形退化为一条链，问题变成一个类似石子合并（<a href="https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。">https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。</a></p><p>由于运算符中存在乘法，故而不能将状态设计为<strong>最大值</strong>，因为一个负的最大值和一个正的最大值的乘积可能是一个很小的值。因此，还需要设计一个<strong>最小值</strong>状态，在乘法更新的时候，需要枚举<strong>最大值、最小值</strong>相乘的四种情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NINF = <span class="hljs-number">-0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MUL = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> dp_max[N][N];<br><span class="hljs-keyword">int</span> dp_min[N][N];<br><br><span class="hljs-keyword">int</span> val[N];<br><span class="hljs-keyword">int</span> op[N];<span class="hljs-comment">// 0-add, 1-mul</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> tot)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>            dp_max[i][j]=NINF;<br>            dp_min[i][j]=INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;len&lt;=tot;len++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l+len<span class="hljs-number">-1</span>&lt;tot;l++)&#123;<br>            <span class="hljs-keyword">int</span> r = l+len<span class="hljs-number">-1</span>;<br>            <br>            <span class="hljs-keyword">int</span> _l = (l+start)%tot;<br>            <span class="hljs-keyword">if</span> (len==<span class="hljs-number">1</span>)&#123;<br>                dp_max[l][r] = val[_l];<br>                dp_min[l][r] = val[_l];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l; k&lt;r; k++)&#123;<br>                <span class="hljs-keyword">int</span> _op = op[(k+<span class="hljs-number">1</span>+start)%tot];<br>                <span class="hljs-keyword">if</span> (_op==ADD)&#123;<br>                    dp_max[l][r] = max(dp_max[l][r], dp_max[l][k]+dp_max[k+<span class="hljs-number">1</span>][r]);<br>                    dp_min[l][r] = min(dp_min[l][r], dp_min[l][k]+dp_min[k+<span class="hljs-number">1</span>][r]);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (_op==MUL)&#123;<br>                    <span class="hljs-keyword">int</span> MM = dp_max[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> Mm = dp_max[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mM = dp_min[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mm = dp_min[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    dp_max[l][r] = max(dp_max[l][r],max(MM,max(Mm,max(mM,mm))));<br>                    dp_min[l][r] = min(dp_min[l][r], min(MM,min(Mm,min(mM,mm))));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_max[<span class="hljs-number">0</span>][tot<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tot;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;tot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">char</span> ch;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;ch;<br>        op[i] = (ch==<span class="hljs-string">&#x27;t&#x27;</span>)?ADD:MUL;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;val[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans_set;<br>    <span class="hljs-keyword">int</span> max_val=NINF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">int</span> tem_val = solve(i,tot);<br>        <span class="hljs-keyword">if</span>(tem_val&gt;max_val)&#123;<br>            max_val = tem_val;<br>            ans_set.clear();<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem_val == max_val)&#123;<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;max_val&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans_set)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>算法</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA1 实验过程</title>
    <link href="/2021/01/28/CS143-PA1/"/>
    <url>/2021/01/28/CS143-PA1/</url>
    
    <content type="html"><![CDATA[<p>cs143在线课程的第一次PA十分简单，熟悉<code>cool</code>语言，并实现一个简单的Stack Machine。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方提供了一个unbuntu 10.05版本的上古虚拟机（真的是上古，<code>sudo apt-get update</code>都已经404了），虚拟机内提供了实验所需的环境；另一种方式是直接使用32位（如果使用64位的机器，需要自己折腾一下spim的安装）的linux虚拟机进行实验。</p><p>我采取了第二种配置方式，因为自己的32bit虚拟机上有vscode，比起vim更加人性化，阅读源码也比较方便。</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>PA1非常简单，实现以下语言的解释器：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210128203630.png" alt="stackmachine"></p><p><code>cool</code>语言没有高级数据结构，所以首先需要实现一个栈（使用<code>list</code>实现即可）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span>&#123;<br>   mystack : List&lt;-<span class="hljs-keyword">new</span> List;<br><br>   push(s: String): Object&#123;<br>      mystack &lt;- mystack.cons(s)<br>   &#125;;<br><br>   pop(): Object &#123;<br>      mystack &lt;- mystack.tail()<br>   &#125;;<br><br>   top(): String &#123;<br>      <span class="hljs-keyword">if</span> mystack.isNil() then<br>         <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-keyword">else</span><br>         mystack.head()<br>      fi&#125;;<br><br>   list():List&#123;mystack&#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>接着使用<code>StackMachine</code>类完成解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackMachine</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span></span>&#123;<br>   mystack: Stack&lt;-<span class="hljs-keyword">new</span> Stack;<br>   mya2i: A2I&lt;-<span class="hljs-keyword">new</span> A2I;<br>   print_list(l : List) : Object &#123;<br>      <span class="hljs-keyword">if</span> l.isNil() then <span class="hljs-number">0</span><br>                   <span class="hljs-keyword">else</span> &#123;<br>   out_string(l.head());<br>   out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>   print_list(l.tail());<br>      &#125;<br>      fi<br>   &#125;;<br><br>   readCommand(ch: String):Bool&#123;<br>      &#123;<br>         out_string(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>         out_string(ch);<br>         out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>         <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;e&quot;</span> then &#123;<br>            let stacktop:String &lt;- mystack.top() in &#123;<br>               <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;+&quot;</span> then&#123;<br>                  mystack.pop();<br>                  let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(mya2i.i2a(mya2i.a2i(v1)+mya2i.a2i(v2)));<br>                  &#125;;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;s&quot;</span> then&#123;<br>                     mystack.pop();<br>                     let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(v1);<br>                     mystack.push(v2);<br>                  &#125;;<br>                  &#125;<br>                  <span class="hljs-keyword">else</span>&#123;<br>                     <span class="hljs-number">0</span>;<br>                  &#125;<br>                  fi;<br>               &#125;<br>               fi;<br>            &#125;;<br>            <span class="hljs-keyword">true</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;d&quot;</span> then&#123;<br>               print_list(mystack.list());<br>               <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;x&quot;</span>then&#123;<br>                  <span class="hljs-keyword">false</span>;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  mystack.push(ch);<br>                  <span class="hljs-keyword">true</span>;<br>               &#125;<br>               fi;<br>            &#125;<br>            fi;<br>         &#125;<br>         fi;<br>      &#125;<br>   &#125;;<br><br>   <br>&#125;;<br></code></pre></td></tr></table></figure><p>不是特别熟悉<code>cool</code>，所以代码写的挺烂的。</p><p>最后在主函数调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span> </span>&#123;<br><br>   main() : Object &#123;<br>      let mystackmachine:StackMachine&lt;-<span class="hljs-keyword">new</span> StackMachine in &#123;<br>         <span class="hljs-keyword">while</span> mystackmachine.readCommand(in_string())loop<br>            <span class="hljs-number">0</span><br>         pool;<br>      &#125;<br>   &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COOL语言入门（正在更新中）</title>
    <link href="/2021/01/26/cool-01/"/>
    <url>/2021/01/26/cool-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>说明</strong></p><p>本文为笔者学习CS 143过程中，阅读Cool Manual所做笔记（基本上是内容的翻译以及简化）。</p></blockquote><h3 id="什么是cool"><a href="#什么是cool" class="headerlink" title="什么是cool"></a>什么是<code>cool</code></h3><p><code>cool</code>的全称是Classroom Object-Oriented Language，是Standford为了教学而创造的一种编程语言。CS 143 课程的Programming Assignment 就是完成<code>cool</code>语言的编译器。</p><h3 id="cool的主要特性"><a href="#cool的主要特性" class="headerlink" title="cool的主要特性"></a><code>cool</code>的主要特性</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>cool</code>使用<code>coolc</code>进行编译，编译指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/coolc [ -o fileout ] file1.cl file2.cl ... filen.cl<br></code></pre></td></tr></table></figure><p>和<code>gcc</code>语法类似，<code>-o</code>之后为输出的文件名（该项可选，默认为之后跟着的第一个文件名+<code>.s</code>）；<code>file1.cl, file2.cl</code>为需要编译的源程序文件名（<code>cool</code>的文件后缀为<code>.cl</code>）。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>coolc</code>输出的是MIPS汇编指令，可以通过<code>spim</code>运行（<code>spim</code>实际上就是MIPS倒过来）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim<br>(spim) load <span class="hljs-string">&quot;file.s&quot;</span><br>(spim) run<br></code></pre></td></tr></table></figure><p>一般使用如下语句直接进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim -file file.s<br></code></pre></td></tr></table></figure><h4 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h4><h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p><code>cool</code>中的所有代码都组织成类。每一个类的所有内容必须被包括在一个源文件中，一个源文件可以包括多个类。</p><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class &lt;type&gt; [ inherits &lt;type&gt; ] &#123;<br>&lt;feature_list&gt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所有的类名（type）都是全局可见的，需要以大写字母开头；类名不可以重复。</p><h6 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h6><p>在<code>cool</code>中，属性（成员变量）以及方法（method）被称作feature。</p><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p><code>cool</code>支持继承机制，并且只支持单继承。与<code>Java</code>类似，如果一个类没有显式声明的一个类，那么其默认继承<code>Object</code>。</p><h5 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h5><p><code>cool</code>语言中提供了类型机制，支持在编译时进行类型检查。</p><h6 id="self-type"><a href="#self-type" class="headerlink" title="self type"></a>self type</h6><p>self type 用于class，其类型不固定。根据上下文决定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【折腾】脱胎换骨的 断桨</title>
    <link href="/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/"/>
    <url>/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用hexo建站"><a href="#为什么使用hexo建站" class="headerlink" title="为什么使用hexo建站"></a>为什么使用hexo建站</h3><p>之前使用namesilo购买过一个域名，使用aliyun配合Wordpress建立了一个小站：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125224831.png" alt="Wordpress建站"></p><p>emmm……看起来有一点朴素。使用Wordpress的过程中，我主要感受到了以下的几个问题：</p><ol><li>配置不自由。自带的主题过少，一些高质量的主题需要氪金（不过也没有什么特别喜欢的风格）；</li><li>服务器配置过低。这是我自身的原因，我在aliyun上租的是一个一核的服务器，实在是不太行，每一次访问站点的时候都卡的不行，服务器还崩过几次（明明没有人访问啊！）；</li><li>写作必须要在线环境。似乎没有找到什么本地写作，然后远程自动更新的方式（可能还是我太菜了），每一次想要写作的时候，都要在Wordpress 的后台上写，实在是不方便啊！</li><li>要备案。我是一条懒狗，到现在还没有备案（苦笑）。</li></ol><p>相比之下，我通过hexo + GithubPages配置的过程就十分轻松了：</p><ol><li>hexo 本身只需要一些简单的配置（node.js之类，也就是命令行随便敲一敲）；</li><li>GithubPages更是一步解决了服务器以及备案的问题（国外的服务器，不需要备案了）；</li><li>hexo 支持本地编辑。hexo 目前使用下来就是本地写作,然后<code>hexo g&amp;hexo d</code>素质三连，十分符合我的写作习惯；</li><li>定制化空间高。比如我现在使用的主体就来自一个开源的项目，颜值在线。</li></ol><h3 id="新的断桨，将会包含哪些内容？"><a href="#新的断桨，将会包含哪些内容？" class="headerlink" title="新的断桨，将会包含哪些内容？"></a>新的断桨，将会包含哪些内容？</h3><blockquote><p> 博客只是一个载体，重要的是内部承载的内容。</p></blockquote><p>目前的想法是，连载自己的<strong>课程笔记、读书笔记、项目介绍</strong>等专业性比较强的内容的同时，也加入一些诸如<strong>漫评、影评</strong>的娱乐性内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lexier</title>
    <link href="/2021/01/25/Lexer/"/>
    <url>/2021/01/25/Lexer/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Lexcial-Analyzer"><a href="#什么是Lexcial-Analyzer" class="headerlink" title="什么是Lexcial Analyzer"></a>什么是Lexcial Analyzer</h3><p>我们知道，编译器的输入是源程序(source program)，然而，编译器无法直接<strong>理解</strong>程序中的<strong>字符串</strong>（尽管他们是结构化的语言），需要进行进一步的结构化。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125222819.png" alt="image-20210125222819890"></p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好！过客</title>
    <link href="/2021/01/25/NewBegin/"/>
    <url>/2021/01/25/NewBegin/</url>
    
    <content type="html"><![CDATA[<p>你是现在世界上少数几个知道本网站存在的人之一，恭喜你，幸运儿！</p><p>以下是对博客框架<code>hexo</code>以及博客主题<code>Fluid</code>的一些简单测试，并没有什么具体的含义。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><script type="math/tex; mode=display">L_o(p,w_o) = L_e(p, w_o) + \int_{\Omega^+}L_i(p,w_i)f_r(p, w_i,w_o)cos\theta\ d\omega</script><h3 id="Path-Tracing伪代码"><a href="#Path-Tracing伪代码" class="headerlink" title="Path Tracing伪代码"></a><code>Path Tracing</code>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shade (p, w_o):<br>blabla<br>......<br>    <span class="hljs-keyword">return</span> L_dir + L_indir<br></code></pre></td></tr></table></figure><h3 id="寒假计划"><a href="#寒假计划" class="headerlink" title="寒假计划"></a>寒假计划</h3><ol><li>吃</li><li>喝</li><li>睡</li></ol><h4 id="来一些图表"><a href="#来一些图表" class="headerlink" title="来一些图表"></a>来一些图表</h4><p>测试图床：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125223350.png" alt="image-20210125223350250"></p><p>测试表格：</p><div class="table-container"><table><thead><tr><th>id</th><th>名称</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>皮卡丘</td><td>电系</td></tr><tr><td>2</td><td>喷火龙</td><td>火，飞行</td></tr><tr><td>3</td><td>迪奥西斯</td><td>超能</td></tr></tbody></table></div><h3 id="测试各种简单的语法"><a href="#测试各种简单的语法" class="headerlink" title="测试各种简单的语法"></a>测试各种简单的语法</h3><p><strong>如果让你重新来过，你会不会爱我</strong></p><blockquote><p>爱情让人拥有快乐，也会带来折磨</p></blockquote><p>We used to be lovers.</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
