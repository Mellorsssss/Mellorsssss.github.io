<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【线性DP】机器人跳跃问题</title>
    <link href="/2021/02/15/tj210215/"/>
    <url>/2021/02/15/tj210215/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/732/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，原问题的解显然具有单调性——如果一个解比最优解大，那么其一定也是可行的，因为其在每一个点<strong>减少的更少，增加的更多</strong>。显然，本题可以使用二分判定一个解，不过该做法因为数据大小限制，不可行（在check解的过程中会溢出）。</p><p>那么，我们可以直接推出最优解吗？简单倒推，在最后一个站点，为了通过的最小能量值实际上就是该站点能量的一半（向上取整）；那么倒数第二个站点，为了通过的最小能量值就是通过当前站点并且可以通过下一个站点：<script type="math/tex">E+(E-cur_e)\ge E_{pass_next}</script>。根据该式子倒推即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span> +<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">int</span> H[N];<br><span class="hljs-keyword">int</span> dp[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-built_in">memset</span>(H, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> H);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;H[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        dp[i] = (H[i]+dp[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;dp[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>思维</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【差分】积木大赛</title>
    <link href="/2021/02/14/tj210214/"/>
    <url>/2021/02/14/tj210214/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/509/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看到区间上加减同一值的操作，容易想到使用差分预处理。原问题变成，如何通过<code>(+1,-1)</code>的成对操作，使得数组中所有数字变成0。</p><p>一个直观的策略是，对于每一个负数，我们应该通过其之前的正数将其抵消。根据差分的定义，<script type="math/tex">\sum_{i=1}^{j}b_i = a_i</script>，而<script type="math/tex">a_i>0</script>，故而对于任何一个负数，一定可以找到一系列正数来与之抵消，我们的方法是合法的。其次，无论是哪一种方法，至少都需要将其中每一个负数变成正数，故而我们的方法是最优的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> D[N];<br><span class="hljs-keyword">int</span> a[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-built_in">memset</span>(D, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> D);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        D[i] = a[i] - a[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    D[n+<span class="hljs-number">1</span>] = -a[n];<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span> (D[i]&lt;<span class="hljs-number">0</span>)ans += -D[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>差分</tag>
      
      <tag>思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【区间DP】加分二叉树</title>
    <link href="/2021/02/10/tj210210/"/>
    <url>/2021/02/10/tj210210/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/481/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果只知道一棵树的中序遍历，无法确定这一棵树的构造；不过，我们可以通过假定各个子树的根，从中序遍历中构造出一颗符合条件的树（有多少种可能实际上也可以通过动态规划求出）。</p><p>如果我们选定了一个根，其子树的最大值与该根无关，换而言之，问题具有最优子结构。自然而然的，我们应该使用一个中序遍历的区间作为状态（唯一确定一个最大值），原问题实际上就变成了一个区间DP 问题。</p><p>由于此处需要我们重构一棵树，所以保存每一个区间的最优节点，这样就可以通过dfs还原树。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">int</span> dp[N][N];<br><span class="hljs-keyword">int</span> best[N][N];<br><span class="hljs-keyword">int</span> val[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arrlen)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len =<span class="hljs-number">1</span>;len&lt;=arrlen;len++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=arrlen;i++)&#123;<br>            <span class="hljs-keyword">int</span> j = i+len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)&#123;<br>                dp[i][i] = val[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">int</span> maxv = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=j;k++)&#123;<br>                <span class="hljs-keyword">int</span> root = val[k];<br>                <span class="hljs-keyword">int</span> left=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span>&gt;=i)left = dp[i][k<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">int</span> right =<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&lt;=j)right = dp[k+<span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">int</span> tem = root + left*right;<br>                <br>                <span class="hljs-keyword">if</span>(tem&gt;maxv)&#123;<br>                    best[i][j] = k;<br>                    maxv = tem;<br>                &#125;<br>            &#125;<br>            dp[i][j] = maxv;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][arrlen];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        q.push_back(l);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> best_root = best[l][r];<br>    q.push_back(best_root);<br>    build_tree(l,best_root<span class="hljs-number">-1</span>,q);<br>    build_tree(best_root+<span class="hljs-number">1</span>,r,q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cin</span>&gt;&gt;val[i];<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;pre_order;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;solve(n)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    build_tree(<span class="hljs-number">1</span>,n,pre_order);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pre_order.size();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;pre_order[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Predictive Parse</title>
    <link href="/2021/02/10/ttt/"/>
    <url>/2021/02/10/ttt/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Predictive-Parse"><a href="#什么是Predictive-Parse" class="headerlink" title="什么是Predictive Parse"></a>什么是Predictive Parse</h3><p>通过提前看token的类型，合理推断产生式。</p><p>在CS 143课程中，我们讨论LL(1)文法。即<strong>从左到右、最左推导</strong>，每次提前看一个token的文法。</p><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p><code>T[A,a]</code>表示当前non terminal 为A,token为a，此时应该使用的推导。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="预处理——left-factor"><a href="#预处理——left-factor" class="headerlink" title="预处理——left factor"></a>预处理——left factor</h4><p>理想情况下，我们可以通过当前的non terminal以及token判断出应该采用什么样的产生式，但是如果出现如下的一些产生式，会出现无法判断的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143351.png" alt="image-20210210143351122"></p><p>对于T而言，它有两个<code>int</code>开头的产生式，无法直接判断应该使用哪一个产生式。</p><p>为了解决这样的一个问题，通过left factor的方法延迟决定：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143603.png" alt="image-20210210143603732"></p><h4 id="基于栈的Predictive-Parse算法"><a href="#基于栈的Predictive-Parse算法" class="headerlink" title="基于栈的Predictive Parse算法"></a>基于栈的Predictive Parse算法</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143745.png" alt="image-20210210143744977"></p><p>算法维护一个栈，通过Parsing Table来完成栈中元素的更新，直至某一个更新出现error或者栈为空（已经完美匹配）。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210143916.png" alt="image-20210210143916660"></p><p>任意一个时刻，栈顶元素只可能有两种情况：终结符或者非终结符。</p><p>如果是一个终结符，那么直接比较该终结符是否与当前的token匹配，如果不匹配则error；反之，完成匹配，弹出栈顶。</p><blockquote><blockquote><p> 是否可能出现input stream中的token使用完，*next++出错的情况？</p></blockquote><p>为了避免这种情况出现，我们将<script type="math/tex">`作为终结符分别放入input stream以及stack中。如果input stream中token使用完，那么一定会遇到`</script>，从而避免了该情况。</p></blockquote><p>如果是一个非终结符，根据Parsing Table，如果不存在一个对应的表项，error;反之，弹出当前栈顶，将产生式放入栈中。</p><h3 id="Parsing-Table的产生"><a href="#Parsing-Table的产生" class="headerlink" title="Parsing Table的产生"></a>Parsing Table的产生</h3><p>Predictve Parse算法的实现需要Parsing Table，下面从First Set,Follow Set的定义开始，分析如何通过他们来构造一个Parsing Table。</p><h4 id="基本观察"><a href="#基本观察" class="headerlink" title="基本观察"></a>基本观察</h4><p>Parsing Table应该满足什么样的性质？换而言之，我们是如何根据当前的非终结符以及下一个token的值，确定我们应该采用什么样的产生式的？对于<script type="math/tex">T[A,a]</script>，如果<script type="math/tex">A\to \alpha</script>，我们有以下的两个观察：</p><p>首先，如果<script type="math/tex">\alpha \to^* t\beta</script>，那么显然<script type="math/tex">T[A, t]=\alpha</script>（此处我们不讨论是否可能存在不止一个<script type="math/tex">\alpha</script>满足该情况）；如果<script type="math/tex">\alpha \to \epsilon\ \& S\to ^* \beta At\sigma</script>，那么也应该<script type="math/tex">T[A,t]=\alpha</script>，因为哦我们可以忽略当前的<script type="math/tex">A</script>，最终也可以完成匹配。</p><p>对于第一种情况，我们称<script type="math/tex">t\in First(\alpha)</script>；对于第二种情况，我们称<script type="math/tex">t\in Follow(A)</script>。尽管我们现在还没有给First Set以及Follow Set一个具体的定义，但是我们可以大概猜到他们的含义：前者表示出现在其句子的最左的终结符；后者表示存在一个句型使得出现在其后的终结符。</p><h4 id="First-Set"><a href="#First-Set" class="headerlink" title="First Set"></a>First Set</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150021.png" alt="image-20210210150021156"></p><p>简单说来，就是<script type="math/tex">X</script>的所有句子中最左边的终结符或者<script type="math/tex">\epsilon</script>。值得注意的是，终结符也是存在First Set的。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150235.png" alt="image-20210210150235704"></p><p>显然，该算法实际上是递归定义的，递归基就是终结符。</p><h4 id="Follow-Set"><a href="#Follow-Set" class="headerlink" title="Follow Set"></a>Follow Set</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150609.png" alt="image-20210210150609810"></p><blockquote><p>简单说来，就是所有存在非终结符<script type="math/tex">X</script>的句型中，其后的终结符。</p></blockquote><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210150748.png" alt="image-20210210150748004"></p><p>第一个性质是显然的，因为根据定义，<script type="math/tex">A</script>之后的所有终结符在Follow(A)中；</p><p>第二个性质有一点点抽象，简单说来，由于B是该产生式中的最后一个元素，故而对于所有有X的句型，都可以将其替换成xxB，故而其后的终结符也一定在Follow(B)中；</p><p>第三个性质是根据我们的Predictive Parse的算法架构，应该加上这样一个限制。</p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210151101.png" alt="image-20210210151101392"></p><p>需要注意的是此处的第三条规则，根据First Set的定义以及上一节中的第二条性质，我们得出了该结论。</p><h4 id="根据First-Set以及Follow-Set生成Parsing-Table"><a href="#根据First-Set以及Follow-Set生成Parsing-Table" class="headerlink" title="根据First Set以及Follow Set生成Parsing Table"></a>根据First Set以及Follow Set生成Parsing Table</h4><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><p>实际上就是我们在介绍Firset Set以及Follow Set时提出的方案：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210152257.png" alt="image-20210210152257231"></p><blockquote><p><strong>一些细节</strong></p><p>对于<script type="math/tex">A\to\alpha</script>，此处的<script type="math/tex">\alpha</script>实际上可能是一个非终结符与终结符的混合，我们需要根据First Set来判断使用哪一个First Set；</p></blockquote><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>前文讨论过，如果出现了一个表项对应多个产生式，应该如何解决？实际上，这就说明该语言实际上无法通过LL(1)文法表达。</p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【复习】正则化</title>
    <link href="/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><h4 id="什么是过拟合与欠拟合"><a href="#什么是过拟合与欠拟合" class="headerlink" title="什么是过拟合与欠拟合"></a>什么是过拟合与欠拟合</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210100655.png" alt="image-20210210100648682"></p><p>训练过程中，如果训练集中的特征数量过多，很有可能导致训练出的模型在训练集上的表现过好，我们称之为过拟合。这本来是一件美好的事情，然而此时的拟合情况优秀实际上是难以<strong>泛化</strong>的，我们需要极力避免这样的情况出现。</p><p>相反地，如果一个模型在训练集上拟合水平过低，我们称之为欠拟合。欠拟合的情况可以通过增加数据量来解决。</p><h4 id="如何避免过拟合"><a href="#如何避免过拟合" class="headerlink" title="如何避免过拟合"></a>如何避免过拟合</h4><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210210101123.png" alt="image-20210210101123699"></p><p>既然过拟合的主要原因是特征数量过多，模型学习到了不应该学习的内容，那么一个可行的解决措施就是<strong>特征工程</strong>——减少特征数量或者选择一些具有代表性的特征；其次，我们也可以通过正则化的方式削弱特征的作用，避免过拟合。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>习题解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OnComponentBeginOverlap签名参数问题</title>
    <link href="/2021/02/10/UE4-210210/"/>
    <url>/2021/02/10/UE4-210210/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>UE4.25版本中，为事件<code>OnComponentBeginOverlap</code>添加委托，对应签名为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DECLARE_DYNAMIC_MULTICAST_SPARSE_DELEGATE_SixParams( FComponentBeginOverlapSignature, UPrimitiveComponent, OnComponentBeginOverlap, UPrimitiveComponent*, OverlappedComponent, AActor*, OtherActor, UPrimitiveComponent*, OtherComp, int32, OtherBodyIndex, <span class="hljs-keyword">bool</span>, bFromSweep, <span class="hljs-keyword">const</span> FHitResult &amp;, SweepResult);<br></code></pre></td></tr></table></figure><p>如果此处直接复制签名中的参数，无法通过编译。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>去掉第一个参数（OnComponentBeginOverlap）即可。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>UE4中为事件添加委托的一般流程：确定委托签名 -&gt; 编写回调函数 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术细节</tag>
      
      <tag>UE4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【思维】池塘钓鱼</title>
    <link href="/2021/02/09/tj210209/"/>
    <url>/2021/02/09/tj210209/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/1264/">ACwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然，一个最优的方案一定是依次在若干个鱼塘钓鱼，没有往返路途（否则，返回时所钓的鱼可以在第一次位于该鱼塘时钓出）。问题在与，如何求出最优的一个鱼塘序列？确定了一个鱼塘序列之后，应该在每一个鱼塘钓多少鱼？</p><p>确定在哪些鱼塘钓鱼是困难的，但是我们可以<script type="math/tex">O(N)</script>枚举可能的鱼塘。确定了鱼塘序列之后，类比多路归并的思路，显然我们可以在<script type="math/tex">O(log N)</script>复杂度内确定在哪一个池塘钓鱼（求解的值并不是时间连续的，但是显然可以排列成一个合法的序列）。</p><p>最终的时间复杂度是<script type="math/tex">O(N*T*logN)</script>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> sub;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;n1, <span class="hljs-keyword">const</span> node &amp; n2)&#123;<br>        <span class="hljs-keyword">return</span> n1.val&lt;n2.val;<br>    &#125;<br>&#125;;<br><br>node d[N];<br><span class="hljs-keyword">int</span> road_time [N];<br><span class="hljs-built_in">priority_queue</span>&lt;node, <span class="hljs-built_in">vector</span>&lt;node&gt; &gt;pq;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> tot_time)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cur_time = tot_time;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr_len;i++)&#123;<br>        cur_time = tot_time;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cur_time -= road_time[j];<br>            <span class="hljs-keyword">if</span>(cur_time&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(pq.size())pq.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            pq.push(d[j]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> tem_ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pq.size() &amp;&amp; cur_time &gt;<span class="hljs-number">0</span>)&#123;<br>            cur_time --;<br>            node topnode = pq.top();pq.pop();<br>            tem_ans += topnode.val;<br>            <span class="hljs-keyword">if</span>(topnode.val-topnode.sub&gt;<span class="hljs-number">0</span>)&#123;<br>                pq.push(node&#123;topnode.val-topnode.sub, topnode.sub&#125;);<br>            &#125;<br>        &#125;<br>        ans = max(ans, tem_ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;d[i].val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;d[i].sub;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;road_time[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> tot_time;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;tot_time;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;solve(n,tot_time)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【二分】借教室</title>
    <link href="/2021/02/06/tj210206/"/>
    <url>/2021/02/06/tj210206/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/505/">Acwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始没有读清题目，以为遇到了一个不满足的人之后会忽略他，继续处理，所以想的复杂了一点。</p><p>我们假设实际可以满足的人数为n，处理的人数为x。显然，如果x&gt;n，那么一定不满足；换而言之，可以通过二分来查找最小的一个满足条件的解（也就是n）。</p><p>二分本身为对数复杂度，考虑到本题的数据量，二分中判断的复杂度应该是线性的。问题的判定是对一个数组进行x次的区间减法，之后的区间中是否存在负值。如果采用朴素的方法，那么每一次区间减法需要线性复杂度，整体需要平方复杂度，显然 不符合要求。这里需要使用<strong>差分</strong>的方法，将区间减法变为点减法，时间复杂度也就变为线性复杂度。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>ll S[N];<br>ll A[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> l;<br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-keyword">int</span> dat;<br>&#125; interval[N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(S, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(S));<br>    S[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;i++)&#123;<br>        S[i] = A[i]-A[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=mid;i++)&#123;<br>        S[interval[i].l] -= interval[i].dat;<br>        S[interval[i].r+<span class="hljs-number">1</span>] +=  interval[i].dat;<br>    &#125;<br>    <br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>        res += S[i];<br>        <span class="hljs-keyword">if</span> (res&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;                          <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> interval_len)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = interval_len + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(is_valid(mid, arr_len))&#123;<br>            r = mid; <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (l==interval_len+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;A[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;interval[i].dat&gt;&gt;interval[i].l&gt;&gt;interval[i].r;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = solve(n,m);<br>    <span class="hljs-keyword">if</span>(res)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;-1\n&quot;</span>&lt;&lt;res&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;0\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bison 简单上手</title>
    <link href="/2021/02/06/Bison-Tutorial/"/>
    <url>/2021/02/06/Bison-Tutorial/</url>
    
    <content type="html"><![CDATA[<p> Bison的文档十分详细，也可以说是冗长，故而此处对其中的一些核心机制做一个简单的总结。</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>可以像flex中一样为rules添加Action，在规则之后的一个block中定义语法。</p><p>bison中提供了机制实现semantic value的计算。使用$$$$可以访问起始符的值（规则左边的non terminal），<code>$n</code>可以访问第n个non terminal的值，此处n从1开始。如果n小于等于0，则使用当前parse stack上的非终结符值（risky）。</p><h3 id="Bison-Decalrations"><a href="#Bison-Decalrations" class="headerlink" title="Bison Decalrations"></a>Bison Decalrations</h3><h4 id="Token-Kind-Names"><a href="#Token-Kind-Names" class="headerlink" title="Token Kind Names"></a>Token Kind Names</h4><p>对于terminal的声明。</p><h4 id="Operator-Precedence"><a href="#Operator-Precedence" class="headerlink" title="Operator Precedence"></a>Operator Precedence</h4><p>对于优先级的声明。</p><p>使用%left 表示优先左结合，%right同理。</p><h4 id="Nonterminal-Symbols"><a href="#Nonterminal-Symbols" class="headerlink" title="Nonterminal Symbols"></a>Nonterminal Symbols</h4>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【二分/前缀和】聪明的质检员</title>
    <link href="/2021/02/05/tj210205/"/>
    <url>/2021/02/05/tj210205/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/description/501/">Acwing</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>容易发现，当<script type="math/tex">W$$$增加时， $$$Y</script>单调不增。直接二分即可。</p><p>一个需要注意的细节是，此处要求的是<script type="math/tex">|Y-S|</script>的最小值。由于二次函数的特殊性 ，实际上我们不需要直接考虑<script type="math/tex">|Y-S|</script>这样一个目标函数（单峰，直接求解需要使用三分法），我们只需要求出<script type="math/tex">S</script>左侧距离其最近的一个点即可，而其右侧距离最小的点一定是所求点的下一个点。</p><p>另一个需要注意的细节是，为了快速求解区间和，需要预处理前缀和。</p><h3 id="题外话-整数域二分的实现"><a href="#题外话-整数域二分的实现" class="headerlink" title="题外话-整数域二分的实现"></a>题外话-整数域二分的实现</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>此处使用的是 lyd书中给出的实现方法，其主要特点为：</p><ol><li>有两种不同的实现二分的形式（分别为求一个数字的后继以及求一个数字的前驱）；</li><li>二分结束时，<script type="math/tex">l</script>若在界内，则一定是解；反之，说明无解。</li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>以下假定使用数组a[1-N]保存单调序列，并且我们使用<strong>满足条件</strong>来完成一定程度的抽象。我们假定，如果一个元素<strong>满足条件</strong>，那么其后继一定也<strong>满足条件</strong>。</p><p>如果是求一个元素的后继（在一个单调的序列中，<strong>满足条件</strong>的最小的一个元素）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* find the next value</span><br><span class="hljs-comment"> * return: -1 means no solution, otherwise the solution</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br><span class="hljs-keyword">int</span> l, r;<br>    l = <span class="hljs-number">1</span>;<br>    r = arr_len; <span class="hljs-comment">// arr_len will never be taken.If l ends at arr_len, there is no such value</span><br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (satisify(a[mid]))&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l == arr_len)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a[l];<br>&#125;<br></code></pre></td></tr></table></figure><p>对以上代码做一个简单的讲解。</p><p><code>line 8</code>: 由于<script type="math/tex">(l+r)>>1</script>永远不会取值<script type="math/tex">r</script>，故而将<script type="math/tex">r</script>设置为一个越界值，如果发现<script type="math/tex">l</script>停留在该值上，说明无解。</p><p><code>line 12</code>:  由于希望找到满足性质的最小元素，并且当前元素满足性质，故而我们舍弃右半区间。</p><p>求一个元素的前驱是类似的，但是需要注意求$mid$时的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* find the previous value</span><br><span class="hljs-comment"> * return: -1 means no solution, otherwise the solution</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br><span class="hljs-keyword">int</span> l, r;<br>    l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0  will never be taken.If l ends at 0, there is no such value</span><br>    r = arr_len<span class="hljs-number">-1</span>; <br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (satisify(a[mid]))&#123;<br>            l = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a[l];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2000000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-comment">/* all starts form index 1 */</span><br>ll w[N];<br>ll v[N];<br>ll sum[N]; <br>ll cnt[N];<br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; interval[N];<br><br><span class="hljs-function">ll <span class="hljs-title">caculate_Y</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W,<span class="hljs-keyword">int</span> arr_len, <span class="hljs-keyword">int</span> interval_len)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cnt));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=arr_len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(w[i]&gt;=W)&#123;<br>            cnt[i]=<span class="hljs-number">1</span>;<br>            sum[i] += v[i];<br>        &#125;<br>        sum[i] += sum[i<span class="hljs-number">-1</span>];<br>        cnt[i] += cnt[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=interval_len;i++)&#123;<br>        ll sum_of_yi = sum[interval[i].second]-sum[interval[i].first<span class="hljs-number">-1</span>];<br>        ll sum_of_cnt = cnt[interval[i].second] - cnt[interval[i].first<span class="hljs-number">-1</span>];<br>        ans += sum_of_yi * sum_of_cnt;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll arr_len, interval_len, S;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;arr_len&gt;&gt;interval_len&gt;&gt;S;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=arr_len;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=interval_len;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;interval[i].first&gt;&gt;interval[i].second;<br>    &#125;<br>    <br>    ll ans = LONG_LONG_MAX;<br>    <br>    <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r =<span class="hljs-number">1000000</span>+<span class="hljs-number">10</span>, mid;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>        ll res = caculate_Y(mid, arr_len, interval_len);<br>        <span class="hljs-keyword">if</span>(res &gt;= S)l = mid;<br>        <span class="hljs-keyword">else</span>&#123;<br>            r = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    ans = min(ans, min(<span class="hljs-built_in">abs</span>(caculate_Y(l, arr_len, interval_len)-S),<span class="hljs-built_in">abs</span>(caculate_Y(l+<span class="hljs-number">1</span>, arr_len, interval_len)-S)));<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【贪心】耍杂技的牛</title>
    <link href="/2021/02/04/tj210204/"/>
    <url>/2021/02/04/tj210204/</url>
    
    <content type="html"><![CDATA[<h3 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h3><p><a href="https://www.acwing.com/problem/content/127/">题目链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>邻项交换模板题。</p><p>考虑两个相邻项，不妨记为<script type="math/tex">w_i</script>以及<script type="math/tex">w_{i+1}</script>，证明如果<script type="math/tex">w_i+s_i>w_{i+1}+s_{i+1}</script>，那么交换这两项可以使得危险度最大值更小。</p><blockquote><p>证明：</p><p>不妨记<script type="math/tex">presum = \sum_{i=1}^{i-1}w_i</script>。交换之前，第<script type="math/tex">i</script>项对应的危险度为<script type="math/tex">presum-s_i</script>，第<script type="math/tex">i+1</script>项的危险度为<script type="math/tex">presum+w_i-s_{i+1}</script>，局部的最大危险度为<script type="math/tex">presum+max(-s_i, w_i-s_{i+1})</script>；交换 之后，第<script type="math/tex">i</script>项对应的危险度为<script type="math/tex">presum+w_{i+1}-s_i</script>，第<script type="math/tex">i+1</script>项对应的危险度为<script type="math/tex">presum-s_{i+1}</script>，局部的最大值为<script type="math/tex">presum+max(-s_{i+1},w_{i+1}-s_i)</script>。由于<script type="math/tex">w_i>0</script>，可知<script type="math/tex">-s_i<w_{i+1}-s_i,-s_{i+1}<w_i-s_{i+1}</script>，故而当<script type="math/tex">w_i+s_i>w_{i+1}+s_{i+1}</script>时，  有交换之前的最大危险度大于交换之后的最大危险度。</p></blockquote><p>由此，以<script type="math/tex">w+s</script>进行排序，排序之后序列中的最大危险度最小。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    ll w;<br>    ll s;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp; n1, <span class="hljs-keyword">const</span> node &amp;n2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (n1.w+n1.s)&gt;(n2.w+n2.s);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000</span> + <span class="hljs-number">10</span>;<br>node a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n ;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    ll sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i].w&gt;&gt;a[i].s;<br>        sum += a[i].w;<br>    &#125;<br>    <br>    sort(a, a+n, cmp);<br>    ll ans = <span class="hljs-number">-999999999</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        ans = max(sum-a[i].w-a[i].s, ans);<br>        sum -= a[i].w;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>贪心</tag>
      
      <tag>邻项交换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和】糖果均摊</title>
    <link href="/2021/02/03/model-jfvp/"/>
    <url>/2021/02/03/model-jfvp/</url>
    
    <content type="html"><![CDATA[<h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p><a href="https://www.acwing.com/problem/content/124/">题目链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有两种思考方式：</p><h5 id="通过均分纸牌问题迁移"><a href="#通过均分纸牌问题迁移" class="headerlink" title="通过均分纸牌问题迁移"></a>通过均分纸牌问题迁移</h5><p><a href="https://www.acwing.com/problem/content/1538/">均分纸牌问题</a>是本题的一个简化版，非环情况。对于非环情况，容易发现，最值就是$\sum<em>{i=1}^{M}|i\times avg-G[i]|$，其中$avg$是所有数的均值（下同），$G[i]$是前缀和。为了简化问题，我们将原先的前缀和$G[i]$预处理为$S[i]=G[i]-i\times avg$（也就是每一个数字减去均值），那么最小值就是$\sum</em>{i=1}^{M}|S[i]|$。</p><p>对于环形情况，一个自然的想法是通过断开环来构造一个最值情况。问题变成是否存在两个点，他们之间没有发生纸牌的传递，<strong>这里的证明我没有想清楚，但是可以猜测，必然存在一组最优解满足该约束</strong>。那么，我们便可以将环从这样的两个点之间断开，从而原问题变成了一个均分纸牌问题。</p><p>当我们从$k$处断开环时，断开之后的环如下（其中$A[i]$是原先的数字减去$avg$之后的值）：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210203205600.JPG" alt="IMG_0214"></p><p>显然，$S[M]=0$，故而所求的最值就是$\sum_{i=1}^{M}|S[i]-S[k]|$，显然最值当$S[k]$为中位数时取得。</p><h5 id="解方程组"><a href="#解方程组" class="headerlink" title="解方程组"></a>解方程组</h5><p>该题解来自于<a href="https://blog.csdn.net/clover_hxy/article/details/71078183">csdn</a>:</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210203205950.png" alt="image-20210203205950654"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>ll sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i];<br>        sum[i]+=sum[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    ll ave = sum[n]/n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        sum[i]-=i*ave;<br>    &#125;<br>    <br>    nth_element(sum+<span class="hljs-number">1</span>, sum+<span class="hljs-number">1</span>+n/<span class="hljs-number">2</span>, sum+n+<span class="hljs-number">1</span>);<br>    ll res =<span class="hljs-number">0</span>;<br>    ll mid = sum[<span class="hljs-number">1</span>+n/<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        res += <span class="hljs-built_in">abs</span>(mid-sum[i]);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和/TRIE】牛异或</title>
    <link href="/2021/02/02/tj-210202-2/"/>
    <url>/2021/02/02/tj-210202-2/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的思路是，使用异或前缀和（异或前缀也具有普通前缀和的性质）枚举所有可能的区间，找出异或值最大的一个区间。显然，在1e5的数据量下，朴素算法会超时。</p><p>如果能够联想到<strong>最大异或对</strong>这道题目，不难发现本题实际上可以转化为该题。</p><p>经过前缀和预处理之后，显然本题就是求出一对最大异或对，不过有以下的一些corner case:</p><ol><li>应该在线处理。如果读取所有的输出再处理，那么需要额外的数据结构来处理<strong>最短区间</strong>这样一个限制；如果在线处理，那么始终保持当前trie中的索引（end标记）是最新的，必然可以保证最短区间这一性质；</li><li>如何判断区间。与普通的前缀和类似，应该从1开始保存（下标0保存0）。这样一来，只有一个元素与有多个元素不需要额外判断（相当于加了一个固定的边界）。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/* Trie */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">1e5</span>*<span class="hljs-number">22</span>;<br><span class="hljs-keyword">int</span> trie[SIZE][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> en[SIZE];<br><span class="hljs-keyword">int</span> tot;<br><span class="hljs-keyword">int</span> STRLEN = <span class="hljs-number">21</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    tot = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(trie,<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(trie));<br>    <span class="hljs-built_in">memset</span>(en, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(en));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (val&gt;&gt;(STRLEN<span class="hljs-number">-1</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val]==<span class="hljs-number">0</span>)trie[p][cur_val]=++tot;<br>        p = trie[p][cur_val];<br>    &#125;<br>    <br>    en[p]=index;<br>&#125;<br><br><br><span class="hljs-comment">/*ds*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_max_xor_index</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (num&gt;&gt;(<span class="hljs-number">20</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val^<span class="hljs-number">1</span>])&#123;<br>            p=trie[p][cur_val^<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p=trie[p][cur_val];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> en[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    init();<br>    <br>    trie_insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">int</span> maxv = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> l=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> r=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i];<br>        sum[i]^=sum[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">int</span> tem_index = get_max_xor_index(sum[i]);<br>        <span class="hljs-keyword">if</span>((sum[i]^sum[tem_index])&gt;maxv)&#123;<br>            maxv = sum[i]^sum[tem_index];<br>            l = tem_index+<span class="hljs-number">1</span>;<br>            r = i;<br>        &#125;<br>        trie_insert(sum[i], i);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;maxv&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和】k倍区间</title>
    <link href="/2021/02/02/tj-210202/"/>
    <url>/2021/02/02/tj-210202/</url>
    
    <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先观察数据范围，1e5，枚举区间显然会tle。<br>观察性质，如果一个区间满足k倍区间性质，那么该有前缀和<code>sum[l-1]%k=sum[r]%k</code>。显然，只需要使用一哈希函数记录每一个键值出现的次数，便可以计算（例如%k=3一共有三个端点，那么一共有2+1=3种可能的区间），遍历一遍前缀和即可。<br>需要注意的是，sum[0]本身也应该参与这个计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span>+<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt[N];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i+<span class="hljs-number">1</span>];<br>        sum[i+<span class="hljs-number">1</span>] += sum[i];<br>    &#125;<br><br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">int</span> mod_res = sum[i]%k;<br>        ans += cnt[mod_res];<br>        cnt[sum[i]%k]++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA2 实验指北</title>
    <link href="/2021/02/01/CS143PA2/"/>
    <url>/2021/02/01/CS143PA2/</url>
    
    <content type="html"><![CDATA[<p>cs143 在线课程的第二次实验，目标为实现cool语言的lexer。整个实验的核心就是通过flex自动化生成lexer，所以我的主要时间都在熟悉flex语法以及使用正则表达式编写规则上。本次实验开始，官方提供了auto grading测试脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210201100339.png" alt="PA2分数"></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="flex熟悉与使用"><a href="#flex熟悉与使用" class="headerlink" title="flex熟悉与使用"></a>flex熟悉与使用</h4><blockquote><p><code>flex</code> is a tool for generating <em>scanners</em>. A scanner is a program which recognizes lexical patterns in text. The <code>flex</code> program reads the given input files, or its standard input if no file names are given, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and C code, called <em>rules</em>. <code>flex</code> generates as output a C source file, ‘<code>lex.yy.c</code>’ by default, which defines a routine <code>yylex()</code>. This file can be compiled and linked with the flex runtime library to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding C code.</p></blockquote><p>flex通过用户编写的规则（包括正则表达式（pattern）以及对应的动作(action)），自动生成一个对应的lexer。</p><p>flex的一些基本规则在实验指南中都有提及，如果想要进一步深入了解flex，个人建议通过<a href="https://garudaxc.github.io/BisonTest/#Introduction">官方文档</a>。</p><h4 id="cool的token-class"><a href="#cool的token-class" class="headerlink" title="cool的token class"></a>cool的token class</h4><p>cool语言主要有以下的几类token class:</p><ol><li>Integers</li><li>Identifiers</li><li>Special Notations</li><li>Strings</li><li>Comments</li><li>Keywords</li><li>White Spaces</li></ol><p>下面逐个介绍如何为其编写flex规则，对于每一个token class，我都从<strong>匹配、semantic value获取</strong>两个方面介绍。</p><h5 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h5><p>在lexical语境下，cool定义的Integers就是0-9数字组成的字符串，故而使用<code>[0-9]+</code>即可匹配。</p><p>在词法分析阶段，不需要对整数的大小做出判断；换而言之 ，此时我们只需要保存Integer对应的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cool_yylval.symbol = inttable.add_string(yytext);<br><span class="hljs-keyword">return</span> INT_CONST;<br></code></pre></td></tr></table></figure><p>这里的cool_yylval是在cool_parse.h中定义的一个自定义数据类型，其保存了在之后阶段中会使用的一系列语义信息，例如symbol中保存了symbol相关的语义值（cool_yylval.symbol的类型就是一个Symbol）；boolean中保存了布尔相关的语义值等等。</p><p>此处的<code>return INT_CONST</code>会在run time嵌入到yylex()中（参见flex文档），其返回值含义是当前token class的编号（各个值的枚举参见cool_parse.h）。</p><h5 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h5><p>cool中的identifiers分为Type Identifiers（例如String, Int）以及Object Identifiers（例如count_down）。</p><blockquote><p><strong>Trap！</strong></p><p>由于后文介绍的Keywords是大小写不敏感的（除了true以及false），故而在编写规则时，应该将Identifiers放到Keywords之后。</p></blockquote><p>两者的匹配与semantic值的设置如出一辙：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">TYPE_ID         [A-Z][A-Za-z0<span class="hljs-number">-9</span>_]*<br>OBJ_ID          [a-z][A-Za-z0<span class="hljs-number">-9</span>_]*<br><br>&#123;TYPE_ID&#125;  &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> TYPEID;<br>           &#125;<br><br>&#123;OBJ_ID&#125;   &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> OBJECTID;<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="Special-Notations"><a href="#Special-Notations" class="headerlink" title="Special Notations"></a>Special Notations</h5><p>Special Notations包括单元、多元运算符、各种基本符号等。对于多元运算符，cool_parse.h中定义了其token_class对应的值，对于单元符号，其自身的ASCII值就是token class对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* </span><br><span class="hljs-comment">  * The single character operators</span><br><span class="hljs-comment">  */</span><br><br>\- |<br>\+ | <br>\~ | <br>\* | <br>\/ | <br>\&lt; | <br>\= | <br>\: | <br>\; | <br>\@ | <br>\&#123; | <br>\&#125; | <br>\, | <br>\. | <br>\( | <br>\) <span class="hljs-keyword">return</span> yytext[<span class="hljs-number">0</span>];<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  The multiple-character operators.</span><br><span class="hljs-comment">  */</span><br><br>&#123;DARROW&#125;&#123; <span class="hljs-keyword">return</span> (DARROW); &#125;<br><br>&#123;ASSIGN&#125;    &#123;<span class="hljs-keyword">return</span> (ASSIGN);&#125;<br><br>&#123;LE&#125;        &#123; <span class="hljs-keyword">return</span> (LE);&#125;<br></code></pre></td></tr></table></figure><h5 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h5><p>字符串的处理包括匹配以及错误处理，较为复杂。</p><p>当遇到一个<code>&quot;</code>时，开始解析字符串，直至出现错误或遇到下一个<code>&quot;</code>完成字符串的封闭。</p><p>在解析过程中，需要注意一些特殊情况：</p><ol><li><p>转义字符。所有以<code>\</code>开头的字符都是转义字符，其解释为<code>\</code>之后的字符；</p><blockquote><p><strong>Trap!</strong></p><p>这里的“所有……”不包括以下字符：</p><p>\n ,\t,\b,\f以及\0</p></blockquote></li><li><p>escaped newline。在一个字符串中，不可以直接连接两行，需要在一行末尾添加<code>\</code>；</p></li><li><p>null字符。如果解析过程中遇到了<code>\0</code>字符，则认为出错；</p></li><li><p>字符串过长。cool中设定字符串至多1024（不包括<code>\0</code>）</p></li></ol><p>此处指出了字符串处理成过程中的几种错误处理：</p><ol><li>中途换行。该错误视为用户没有添加右引号，所以应该从下一行开始解析；</li><li>包含<code>\0</code>字符。该错误视作该字符串无效，故而应该从下一行（如果还存在错误1）或从右引号下一个字符开始解析；</li><li>包含eof。该错误同样视作该字符串无效，处理方式同2；</li><li>字符串过长。处理方式同2。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  String constants (C syntax)</span><br><span class="hljs-comment">  *  Escape sequence \c is accepted for all characters c. Except for </span><br><span class="hljs-comment">  *  \n \t \b \f, the result is c.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  */</span><br><br>\<span class="hljs-string">&quot; &#123;</span><br><span class="hljs-string">    BEGIN(string);</span><br><span class="hljs-string">    str_len = 0;</span><br><span class="hljs-string">    string_buf_ptr = string_buf;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\&quot; &#123;</span><br><span class="hljs-string">            BEGIN(0);</span><br><span class="hljs-string">            *string_buf_ptr = &#x27;\0&#x27;;</span><br><span class="hljs-string">            cool_yylval.symbol = stringtable.add_string(string_buf);</span><br><span class="hljs-string">            return STR_CONST;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\n &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>Unterminated <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(0); /* start from the new line */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\0 &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;&lt;&lt;EOF&gt;&gt; &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>EOF in <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\n |</span><br><span class="hljs-string">&lt;string&gt;\\b |</span><br><span class="hljs-string">&lt;string&gt;\\t |</span><br><span class="hljs-string">&lt;string&gt;\\f &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string">              *string_buf_ptr++ = get_sp_char(yytext[1]);</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\(.|\n) &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">              *string_buf_ptr++ = yytext[1];</span><br><span class="hljs-string">              if (yytext[1]==&#x27;\n&#x27;)&#123;</span><br><span class="hljs-string">                ++curr_lineno;</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">              if (yytext[1]==&#x27;\0&#x27;)&#123;</span><br><span class="hljs-string">                cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">                BEGIN(invalid_string);</span><br><span class="hljs-string">                return (ERROR);</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;[^\\\n\0\&quot;]+ &#123;</span><br><span class="hljs-string">                      char *yyptr = yytext;</span><br><span class="hljs-string">                      while(*yyptr)&#123;</span><br><span class="hljs-string">                        str_len ++;</span><br><span class="hljs-string">                        CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">                        *string_buf_ptr++ = *yyptr++;</span><br><span class="hljs-string">                      &#125;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;invalid_string&gt;[^\n&quot;</span>]*(\n|\<span class="hljs-string">&quot;) BEGIN(0); /* jump to the end of the string */</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>注释分为两种，单行注释（以<code>--</code>开头）以及多行嵌套注释（以<code>(*</code>开头）。</p><p>前者较为简单，后者需要考虑嵌套的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;--&quot;</span>[^\n]* <span class="hljs-comment">/* single line comment, don&#x27;t eat up the \n*/</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  Nested comments</span><br><span class="hljs-comment">  */</span><br><br><br>&#123;LEFTCOMMENT&#125; &#123;<br>              BEGIN(comment);<br>              comment_num =<span class="hljs-number">1</span>;<br>              &#125;<br><br>&lt;comment&gt;&#123;LEFTCOMMENT&#125; &#123;comment_num++;&#125;<br><br>&lt;comment&gt;[^(*\n]+  <span class="hljs-comment">/* eat up all the characters which are not * or newline */</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;(&quot;</span>+[^*]* <span class="hljs-comment">/* eat up all the ( which are not nested (*/</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;*&quot;</span>+[^*)\n]* <span class="hljs-comment">/* eat up all the * which are not follwed by *) or new line*/</span><br><br>&lt;comment&gt;&lt;&lt;EOF&gt;&gt; &#123;<br>            cool_yylval.error_msg = <span class="hljs-string">&quot;EOF in comment&quot;</span>;<br>            BEGIN(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> (ERROR);<br>            &#125;<br><br>&lt;comment&gt;\n ++curr_lineno;<br><br>&lt;comment&gt;&#123;RIGHTCOMMENT&#125; &#123;<br>                          comment_num--;<br>                          <span class="hljs-keyword">if</span> (comment_num ==<span class="hljs-number">0</span>)&#123;<br>                              BEGIN(<span class="hljs-number">0</span>);<br>                          &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure><h5 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h5><p>注意大小写即可，此处按下不表。</p><h5 id="White-Spaces"><a href="#White-Spaces" class="headerlink" title="White Spaces"></a>White Spaces</h5><p>需要将换行符单独考虑，维护代码行数，此处按下不表。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>PA2并不困难，只是较为繁琐（例如String以及Comment中状态机的设计），实验整体耗时大约8小时。</p><p>学习到的知识点：</p><ol><li>lexer工作基本流程；</li><li>flex如何使用，一些较为进阶的小技巧。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【区间DP】Polygon</title>
    <link href="/2021/01/29/tj-211129/"/>
    <url>/2021/01/29/tj-211129/</url>
    
    <content type="html"><![CDATA[<h3 id="题面链接"><a href="#题面链接" class="headerlink" title="题面链接"></a>题面链接</h3><p><a href="https://www.acwing.com/problem/content/description/285/">https://www.acwing.com/problem/content/description/285/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目给出一个多边形，边为运算符，顶点为数值，所求为删去一条边之后，通过不断合并边可以获得的最大值。</p><p>乍一看，删去哪一条边获取最大值是未知的，需要枚举每一条边。</p><p>枚举之后，原来的多边形退化为一条链，问题变成一个类似石子合并（<a href="https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。">https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。</a></p><p>由于运算符中存在乘法，故而不能将状态设计为<strong>最大值</strong>，因为一个负的最大值和一个正的最大值的乘积可能是一个很小的值。因此，还需要设计一个<strong>最小值</strong>状态，在乘法更新的时候，需要枚举<strong>最大值、最小值</strong>相乘的四种情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NINF = <span class="hljs-number">-0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MUL = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> dp_max[N][N];<br><span class="hljs-keyword">int</span> dp_min[N][N];<br><br><span class="hljs-keyword">int</span> val[N];<br><span class="hljs-keyword">int</span> op[N];<span class="hljs-comment">// 0-add, 1-mul</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> tot)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>            dp_max[i][j]=NINF;<br>            dp_min[i][j]=INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;len&lt;=tot;len++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l+len<span class="hljs-number">-1</span>&lt;tot;l++)&#123;<br>            <span class="hljs-keyword">int</span> r = l+len<span class="hljs-number">-1</span>;<br>            <br>            <span class="hljs-keyword">int</span> _l = (l+start)%tot;<br>            <span class="hljs-keyword">if</span> (len==<span class="hljs-number">1</span>)&#123;<br>                dp_max[l][r] = val[_l];<br>                dp_min[l][r] = val[_l];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l; k&lt;r; k++)&#123;<br>                <span class="hljs-keyword">int</span> _op = op[(k+<span class="hljs-number">1</span>+start)%tot];<br>                <span class="hljs-keyword">if</span> (_op==ADD)&#123;<br>                    dp_max[l][r] = max(dp_max[l][r], dp_max[l][k]+dp_max[k+<span class="hljs-number">1</span>][r]);<br>                    dp_min[l][r] = min(dp_min[l][r], dp_min[l][k]+dp_min[k+<span class="hljs-number">1</span>][r]);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (_op==MUL)&#123;<br>                    <span class="hljs-keyword">int</span> MM = dp_max[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> Mm = dp_max[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mM = dp_min[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mm = dp_min[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    dp_max[l][r] = max(dp_max[l][r],max(MM,max(Mm,max(mM,mm))));<br>                    dp_min[l][r] = min(dp_min[l][r], min(MM,min(Mm,min(mM,mm))));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_max[<span class="hljs-number">0</span>][tot<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tot;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;tot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">char</span> ch;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;ch;<br>        op[i] = (ch==<span class="hljs-string">&#x27;t&#x27;</span>)?ADD:MUL;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;val[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans_set;<br>    <span class="hljs-keyword">int</span> max_val=NINF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">int</span> tem_val = solve(i,tot);<br>        <span class="hljs-keyword">if</span>(tem_val&gt;max_val)&#123;<br>            max_val = tem_val;<br>            ans_set.clear();<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem_val == max_val)&#123;<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;max_val&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans_set)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>算法</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA1 实验过程</title>
    <link href="/2021/01/28/CS143-PA1/"/>
    <url>/2021/01/28/CS143-PA1/</url>
    
    <content type="html"><![CDATA[<p>cs143在线课程的第一次PA十分简单，熟悉<code>cool</code>语言，并实现一个简单的Stack Machine。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方提供了一个unbuntu 10.05版本的上古虚拟机（真的是上古，<code>sudo apt-get update</code>都已经404了），虚拟机内提供了实验所需的环境；另一种方式是直接使用32位（如果使用64位的机器，需要自己折腾一下spim的安装）的linux虚拟机进行实验。</p><p>我采取了第二种配置方式，因为自己的32bit虚拟机上有vscode，比起vim更加人性化，阅读源码也比较方便。</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>PA1非常简单，实现以下语言的解释器：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210128203630.png" alt="stackmachine"></p><p><code>cool</code>语言没有高级数据结构，所以首先需要实现一个栈（使用<code>list</code>实现即可）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span>&#123;<br>   mystack : List&lt;-<span class="hljs-keyword">new</span> List;<br><br>   push(s: String): Object&#123;<br>      mystack &lt;- mystack.cons(s)<br>   &#125;;<br><br>   pop(): Object &#123;<br>      mystack &lt;- mystack.tail()<br>   &#125;;<br><br>   top(): String &#123;<br>      <span class="hljs-keyword">if</span> mystack.isNil() then<br>         <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-keyword">else</span><br>         mystack.head()<br>      fi&#125;;<br><br>   list():List&#123;mystack&#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>接着使用<code>StackMachine</code>类完成解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackMachine</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span></span>&#123;<br>   mystack: Stack&lt;-<span class="hljs-keyword">new</span> Stack;<br>   mya2i: A2I&lt;-<span class="hljs-keyword">new</span> A2I;<br>   print_list(l : List) : Object &#123;<br>      <span class="hljs-keyword">if</span> l.isNil() then <span class="hljs-number">0</span><br>                   <span class="hljs-keyword">else</span> &#123;<br>   out_string(l.head());<br>   out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>   print_list(l.tail());<br>      &#125;<br>      fi<br>   &#125;;<br><br>   readCommand(ch: String):Bool&#123;<br>      &#123;<br>         out_string(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>         out_string(ch);<br>         out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>         <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;e&quot;</span> then &#123;<br>            let stacktop:String &lt;- mystack.top() in &#123;<br>               <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;+&quot;</span> then&#123;<br>                  mystack.pop();<br>                  let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(mya2i.i2a(mya2i.a2i(v1)+mya2i.a2i(v2)));<br>                  &#125;;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;s&quot;</span> then&#123;<br>                     mystack.pop();<br>                     let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(v1);<br>                     mystack.push(v2);<br>                  &#125;;<br>                  &#125;<br>                  <span class="hljs-keyword">else</span>&#123;<br>                     <span class="hljs-number">0</span>;<br>                  &#125;<br>                  fi;<br>               &#125;<br>               fi;<br>            &#125;;<br>            <span class="hljs-keyword">true</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;d&quot;</span> then&#123;<br>               print_list(mystack.list());<br>               <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;x&quot;</span>then&#123;<br>                  <span class="hljs-keyword">false</span>;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  mystack.push(ch);<br>                  <span class="hljs-keyword">true</span>;<br>               &#125;<br>               fi;<br>            &#125;<br>            fi;<br>         &#125;<br>         fi;<br>      &#125;<br>   &#125;;<br><br>   <br>&#125;;<br></code></pre></td></tr></table></figure><p>不是特别熟悉<code>cool</code>，所以代码写的挺烂的。</p><p>最后在主函数调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span> </span>&#123;<br><br>   main() : Object &#123;<br>      let mystackmachine:StackMachine&lt;-<span class="hljs-keyword">new</span> StackMachine in &#123;<br>         <span class="hljs-keyword">while</span> mystackmachine.readCommand(in_string())loop<br>            <span class="hljs-number">0</span><br>         pool;<br>      &#125;<br>   &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COOL语言入门（正在更新中）</title>
    <link href="/2021/01/26/cool-01/"/>
    <url>/2021/01/26/cool-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>说明</strong></p><p>本文为笔者学习CS 143过程中，阅读Cool Manual所做笔记（基本上是内容的翻译以及简化）。</p></blockquote><h3 id="什么是cool"><a href="#什么是cool" class="headerlink" title="什么是cool"></a>什么是<code>cool</code></h3><p><code>cool</code>的全称是Classroom Object-Oriented Language，是Standford为了教学而创造的一种编程语言。CS 143 课程的Programming Assignment 就是完成<code>cool</code>语言的编译器。</p><h3 id="cool的主要特性"><a href="#cool的主要特性" class="headerlink" title="cool的主要特性"></a><code>cool</code>的主要特性</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>cool</code>使用<code>coolc</code>进行编译，编译指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/coolc [ -o fileout ] file1.cl file2.cl ... filen.cl<br></code></pre></td></tr></table></figure><p>和<code>gcc</code>语法类似，<code>-o</code>之后为输出的文件名（该项可选，默认为之后跟着的第一个文件名+<code>.s</code>）；<code>file1.cl, file2.cl</code>为需要编译的源程序文件名（<code>cool</code>的文件后缀为<code>.cl</code>）。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>coolc</code>输出的是MIPS汇编指令，可以通过<code>spim</code>运行（<code>spim</code>实际上就是MIPS倒过来）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim<br>(spim) load <span class="hljs-string">&quot;file.s&quot;</span><br>(spim) run<br></code></pre></td></tr></table></figure><p>一般使用如下语句直接进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim -file file.s<br></code></pre></td></tr></table></figure><h4 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h4><h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p><code>cool</code>中的所有代码都组织成类。每一个类的所有内容必须被包括在一个源文件中，一个源文件可以包括多个类。</p><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class &lt;type&gt; [ inherits &lt;type&gt; ] &#123;<br>&lt;feature_list&gt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所有的类名（type）都是全局可见的，需要以大写字母开头；类名不可以重复。</p><h6 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h6><p>在<code>cool</code>中，属性（成员变量）以及方法（method）被称作feature。</p><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p><code>cool</code>支持继承机制，并且只支持单继承。与<code>Java</code>类似，如果一个类没有显式声明的一个类，那么其默认继承<code>Object</code>。</p><h5 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h5><p><code>cool</code>语言中提供了类型机制，支持在编译时进行类型检查。</p><h6 id="self-type"><a href="#self-type" class="headerlink" title="self type"></a>self type</h6><p>self type 用于class，其类型不固定。根据上下文决定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【折腾】脱胎换骨的 断桨</title>
    <link href="/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/"/>
    <url>/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用hexo建站"><a href="#为什么使用hexo建站" class="headerlink" title="为什么使用hexo建站"></a>为什么使用hexo建站</h3><p>之前使用namesilo购买过一个域名，使用aliyun配合Wordpress建立了一个小站：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125224831.png" alt="Wordpress建站"></p><p>emmm……看起来有一点朴素。使用Wordpress的过程中，我主要感受到了以下的几个问题：</p><ol><li>配置不自由。自带的主题过少，一些高质量的主题需要氪金（不过也没有什么特别喜欢的风格）；</li><li>服务器配置过低。这是我自身的原因，我在aliyun上租的是一个一核的服务器，实在是不太行，每一次访问站点的时候都卡的不行，服务器还崩过几次（明明没有人访问啊！）；</li><li>写作必须要在线环境。似乎没有找到什么本地写作，然后远程自动更新的方式（可能还是我太菜了），每一次想要写作的时候，都要在Wordpress 的后台上写，实在是不方便啊！</li><li>要备案。我是一条懒狗，到现在还没有备案（苦笑）。</li></ol><p>相比之下，我通过hexo + GithubPages配置的过程就十分轻松了：</p><ol><li>hexo 本身只需要一些简单的配置（node.js之类，也就是命令行随便敲一敲）；</li><li>GithubPages更是一步解决了服务器以及备案的问题（国外的服务器，不需要备案了）；</li><li>hexo 支持本地编辑。hexo 目前使用下来就是本地写作,然后<code>hexo g&amp;hexo d</code>素质三连，十分符合我的写作习惯；</li><li>定制化空间高。比如我现在使用的主体就来自一个开源的项目，颜值在线。</li></ol><h3 id="新的断桨，将会包含哪些内容？"><a href="#新的断桨，将会包含哪些内容？" class="headerlink" title="新的断桨，将会包含哪些内容？"></a>新的断桨，将会包含哪些内容？</h3><blockquote><p> 博客只是一个载体，重要的是内部承载的内容。</p></blockquote><p>目前的想法是，连载自己的<strong>课程笔记、读书笔记、项目介绍</strong>等专业性比较强的内容的同时，也加入一些诸如<strong>漫评、影评</strong>的娱乐性内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lexier</title>
    <link href="/2021/01/25/Lexer/"/>
    <url>/2021/01/25/Lexer/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Lexcial-Analyzer"><a href="#什么是Lexcial-Analyzer" class="headerlink" title="什么是Lexcial Analyzer"></a>什么是Lexcial Analyzer</h3><p>我们知道，编译器的输入是源程序(source program)，然而，编译器无法直接<strong>理解</strong>程序中的<strong>字符串</strong>（尽管他们是结构化的语言），需要进行进一步的结构化。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125222819.png" alt="image-20210125222819890"></p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好！过客</title>
    <link href="/2021/01/25/NewBegin/"/>
    <url>/2021/01/25/NewBegin/</url>
    
    <content type="html"><![CDATA[<p>你是现在世界上少数几个知道本网站存在的人之一，恭喜你，幸运儿！</p><p>以下是对博客框架<code>hexo</code>以及博客主题<code>Fluid</code>的一些简单测试，并没有什么具体的含义。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><script type="math/tex; mode=display">L_o(p,w_o) = L_e(p, w_o) + \int_{\Omega^+}L_i(p,w_i)f_r(p, w_i,w_o)cos\theta\ d\omega</script><h3 id="Path-Tracing伪代码"><a href="#Path-Tracing伪代码" class="headerlink" title="Path Tracing伪代码"></a><code>Path Tracing</code>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shade (p, w_o):<br>blabla<br>......<br>    <span class="hljs-keyword">return</span> L_dir + L_indir<br></code></pre></td></tr></table></figure><h3 id="寒假计划"><a href="#寒假计划" class="headerlink" title="寒假计划"></a>寒假计划</h3><ol><li>吃</li><li>喝</li><li>睡</li></ol><h4 id="来一些图表"><a href="#来一些图表" class="headerlink" title="来一些图表"></a>来一些图表</h4><p>测试图床：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125223350.png" alt="image-20210125223350250"></p><p>测试表格：</p><div class="table-container"><table><thead><tr><th>id</th><th>名称</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>皮卡丘</td><td>电系</td></tr><tr><td>2</td><td>喷火龙</td><td>火，飞行</td></tr><tr><td>3</td><td>迪奥西斯</td><td>超能</td></tr></tbody></table></div><h3 id="测试各种简单的语法"><a href="#测试各种简单的语法" class="headerlink" title="测试各种简单的语法"></a>测试各种简单的语法</h3><p><strong>如果让你重新来过，你会不会爱我</strong></p><blockquote><p>爱情让人拥有快乐，也会带来折磨</p></blockquote><p>We used to be lovers.</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
