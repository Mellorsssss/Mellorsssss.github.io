<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【前缀和/TRIE】牛异或</title>
    <link href="/2021/02/02/tj-210202-2/"/>
    <url>/2021/02/02/tj-210202-2/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最朴素的思路是，使用异或前缀和（异或前缀也具有普通前缀和的性质）枚举所有可能的区间，找出异或值最大的一个区间。显然，在1e5的数据量下，朴素算法会超时。</p><p>如果能够联想到<strong>最大异或对</strong>这道题目，不难发现本题实际上可以转化为该题。</p><p>经过前缀和预处理之后，显然本题就是求出一对最大异或对，不过有以下的一些corner case:</p><ol><li>应该在线处理。如果读取所有的输出再处理，那么需要额外的数据结构来处理<strong>最短区间</strong>这样一个限制；如果在线处理，那么始终保持当前trie中的索引（end标记）是最新的，必然可以保证最短区间这一性质；</li><li>如何判断区间。与普通的前缀和类似，应该从1开始保存（下标0保存0）。这样一来，只有一个元素与有多个元素不需要额外判断（相当于加了一个固定的边界）。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/* Trie */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">1e5</span>*<span class="hljs-number">22</span>;<br><span class="hljs-keyword">int</span> trie[SIZE][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> en[SIZE];<br><span class="hljs-keyword">int</span> tot;<br><span class="hljs-keyword">int</span> STRLEN = <span class="hljs-number">21</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    tot = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(trie,<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(trie));<br>    <span class="hljs-built_in">memset</span>(en, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(en));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (val&gt;&gt;(STRLEN<span class="hljs-number">-1</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val]==<span class="hljs-number">0</span>)trie[p][cur_val]=++tot;<br>        p = trie[p][cur_val];<br>    &#125;<br>    <br>    en[p]=index;<br>&#125;<br><br><br><span class="hljs-comment">/*ds*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_max_xor_index</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;STRLEN;i++)&#123;<br>        <span class="hljs-keyword">int</span> cur_val = (num&gt;&gt;(<span class="hljs-number">20</span>-i))%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(trie[p][cur_val^<span class="hljs-number">1</span>])&#123;<br>            p=trie[p][cur_val^<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p=trie[p][cur_val];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> en[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    init();<br>    <br>    trie_insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">int</span> maxv = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> l=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> r=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i];<br>        sum[i]^=sum[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">int</span> tem_index = get_max_xor_index(sum[i]);<br>        <span class="hljs-keyword">if</span>((sum[i]^sum[tem_index])&gt;maxv)&#123;<br>            maxv = sum[i]^sum[tem_index];<br>            l = tem_index+<span class="hljs-number">1</span>;<br>            r = i;<br>        &#125;<br>        trie_insert(sum[i], i);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;maxv&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前缀和】k倍区间</title>
    <link href="/2021/02/02/tj-210202/"/>
    <url>/2021/02/02/tj-210202/</url>
    
    <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先观察数据范围，1e5，枚举区间显然会tle。<br>观察性质，如果一个区间满足k倍区间性质，那么该有前缀和<code>sum[l-1]%k=sum[r]%k</code>。显然，只需要使用一哈希函数记录每一个键值出现的次数，便可以计算（例如%k=3一共有三个端点，那么一共有2+1=3种可能的区间），遍历一遍前缀和即可。<br>需要注意的是，sum[0]本身也应该参与这个计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100000</span>+<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt[N];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;sum[i+<span class="hljs-number">1</span>];<br>        sum[i+<span class="hljs-number">1</span>] += sum[i];<br>    &#125;<br><br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">int</span> mod_res = sum[i]%k;<br>        ans += cnt[mod_res];<br>        cnt[sum[i]%k]++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA2 实验指北</title>
    <link href="/2021/02/01/CS143PA2/"/>
    <url>/2021/02/01/CS143PA2/</url>
    
    <content type="html"><![CDATA[<p>cs143 在线课程的第二次实验，目标为实现cool语言的lexer。整个实验的核心就是通过flex自动化生成lexer，所以我的主要时间都在熟悉flex语法以及使用正则表达式编写规则上。本次实验开始，官方提供了auto grading测试脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210201100339.png" alt="PA2分数"></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="flex熟悉与使用"><a href="#flex熟悉与使用" class="headerlink" title="flex熟悉与使用"></a>flex熟悉与使用</h4><blockquote><p><code>flex</code> is a tool for generating <em>scanners</em>. A scanner is a program which recognizes lexical patterns in text. The <code>flex</code> program reads the given input files, or its standard input if no file names are given, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and C code, called <em>rules</em>. <code>flex</code> generates as output a C source file, ‘<code>lex.yy.c</code>’ by default, which defines a routine <code>yylex()</code>. This file can be compiled and linked with the flex runtime library to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding C code.</p></blockquote><p>flex通过用户编写的规则（包括正则表达式（pattern）以及对应的动作(action)），自动生成一个对应的lexer。</p><p>flex的一些基本规则在实验指南中都有提及，如果想要进一步深入了解flex，个人建议通过<a href="https://garudaxc.github.io/BisonTest/#Introduction">官方文档</a>。</p><h4 id="cool的token-class"><a href="#cool的token-class" class="headerlink" title="cool的token class"></a>cool的token class</h4><p>cool语言主要有以下的几类token class:</p><ol><li>Integers</li><li>Identifiers</li><li>Special Notations</li><li>Strings</li><li>Comments</li><li>Keywords</li><li>White Spaces</li></ol><p>下面逐个介绍如何为其编写flex规则，对于每一个token class，我都从<strong>匹配、semantic value获取</strong>两个方面介绍。</p><h5 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h5><p>在lexical语境下，cool定义的Integers就是0-9数字组成的字符串，故而使用<code>[0-9]+</code>即可匹配。</p><p>在词法分析阶段，不需要对整数的大小做出判断；换而言之 ，此时我们只需要保存Integer对应的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cool_yylval.symbol = inttable.add_string(yytext);<br><span class="hljs-keyword">return</span> INT_CONST;<br></code></pre></td></tr></table></figure><p>这里的cool_yylval是在cool_parse.h中定义的一个自定义数据类型，其保存了在之后阶段中会使用的一系列语义信息，例如symbol中保存了symbol相关的语义值（cool_yylval.symbol的类型就是一个Symbol）；boolean中保存了布尔相关的语义值等等。</p><p>此处的<code>return INT_CONST</code>会在run time嵌入到yylex()中（参见flex文档），其返回值含义是当前token class的编号（各个值的枚举参见cool_parse.h）。</p><h5 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h5><p>cool中的identifiers分为Type Identifiers（例如String, Int）以及Object Identifiers（例如count_down）。</p><blockquote><p><strong>Trap！</strong></p><p>由于后文介绍的Keywords是大小写不敏感的（除了true以及false），故而在编写规则时，应该将Identifiers放到Keywords之后。</p></blockquote><p>两者的匹配与semantic值的设置如出一辙：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">TYPE_ID         [A-Z][A-Za-z0<span class="hljs-number">-9</span>_]*<br>OBJ_ID          [a-z][A-Za-z0<span class="hljs-number">-9</span>_]*<br><br>&#123;TYPE_ID&#125;  &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> TYPEID;<br>           &#125;<br><br>&#123;OBJ_ID&#125;   &#123;<br>              cool_yylval.symbol = idtable.add_string(yytext);<br>              <span class="hljs-keyword">return</span> OBJECTID;<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="Special-Notations"><a href="#Special-Notations" class="headerlink" title="Special Notations"></a>Special Notations</h5><p>Special Notations包括单元、多元运算符、各种基本符号等。对于多元运算符，cool_parse.h中定义了其token_class对应的值，对于单元符号，其自身的ASCII值就是token class对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* </span><br><span class="hljs-comment">  * The single character operators</span><br><span class="hljs-comment">  */</span><br><br>\- |<br>\+ | <br>\~ | <br>\* | <br>\/ | <br>\&lt; | <br>\= | <br>\: | <br>\; | <br>\@ | <br>\&#123; | <br>\&#125; | <br>\, | <br>\. | <br>\( | <br>\) <span class="hljs-keyword">return</span> yytext[<span class="hljs-number">0</span>];<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  The multiple-character operators.</span><br><span class="hljs-comment">  */</span><br><br>&#123;DARROW&#125;&#123; <span class="hljs-keyword">return</span> (DARROW); &#125;<br><br>&#123;ASSIGN&#125;    &#123;<span class="hljs-keyword">return</span> (ASSIGN);&#125;<br><br>&#123;LE&#125;        &#123; <span class="hljs-keyword">return</span> (LE);&#125;<br></code></pre></td></tr></table></figure><h5 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h5><p>字符串的处理包括匹配以及错误处理，较为复杂。</p><p>当遇到一个<code>&quot;</code>时，开始解析字符串，直至出现错误或遇到下一个<code>&quot;</code>完成字符串的封闭。</p><p>在解析过程中，需要注意一些特殊情况：</p><ol><li><p>转义字符。所有以<code>\</code>开头的字符都是转义字符，其解释为<code>\</code>之后的字符；</p><blockquote><p><strong>Trap!</strong></p><p>这里的“所有……”不包括以下字符：</p><p>\n ,\t,\b,\f以及\0</p></blockquote></li><li><p>escaped newline。在一个字符串中，不可以直接连接两行，需要在一行末尾添加<code>\</code>；</p></li><li><p>null字符。如果解析过程中遇到了<code>\0</code>字符，则认为出错；</p></li><li><p>字符串过长。cool中设定字符串至多1024（不包括<code>\0</code>）</p></li></ol><p>此处指出了字符串处理成过程中的几种错误处理：</p><ol><li>中途换行。该错误视为用户没有添加右引号，所以应该从下一行开始解析；</li><li>包含<code>\0</code>字符。该错误视作该字符串无效，故而应该从下一行（如果还存在错误1）或从右引号下一个字符开始解析；</li><li>包含eof。该错误同样视作该字符串无效，处理方式同2；</li><li>字符串过长。处理方式同2。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  String constants (C syntax)</span><br><span class="hljs-comment">  *  Escape sequence \c is accepted for all characters c. Except for </span><br><span class="hljs-comment">  *  \n \t \b \f, the result is c.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  */</span><br><br>\<span class="hljs-string">&quot; &#123;</span><br><span class="hljs-string">    BEGIN(string);</span><br><span class="hljs-string">    str_len = 0;</span><br><span class="hljs-string">    string_buf_ptr = string_buf;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\&quot; &#123;</span><br><span class="hljs-string">            BEGIN(0);</span><br><span class="hljs-string">            *string_buf_ptr = &#x27;\0&#x27;;</span><br><span class="hljs-string">            cool_yylval.symbol = stringtable.add_string(string_buf);</span><br><span class="hljs-string">            return STR_CONST;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\n &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>Unterminated <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(0); /* start from the new line */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\0 &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;&lt;&lt;EOF&gt;&gt; &#123;</span><br><span class="hljs-string">            cool_yylval.error_msg = &quot;</span>EOF in <span class="hljs-built_in">string</span> constant<span class="hljs-string">&quot;;</span><br><span class="hljs-string">            BEGIN(invalid_string); /* start from the end of the string */</span><br><span class="hljs-string">            return (ERROR);</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\n |</span><br><span class="hljs-string">&lt;string&gt;\\b |</span><br><span class="hljs-string">&lt;string&gt;\\t |</span><br><span class="hljs-string">&lt;string&gt;\\f &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string">              *string_buf_ptr++ = get_sp_char(yytext[1]);</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;\\(.|\n) &#123;</span><br><span class="hljs-string">              str_len ++;</span><br><span class="hljs-string">              CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">              *string_buf_ptr++ = yytext[1];</span><br><span class="hljs-string">              if (yytext[1]==&#x27;\n&#x27;)&#123;</span><br><span class="hljs-string">                ++curr_lineno;</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">              if (yytext[1]==&#x27;\0&#x27;)&#123;</span><br><span class="hljs-string">                cool_yylval.error_msg = &quot;</span>String contains escaped null character.<span class="hljs-string">&quot;;</span><br><span class="hljs-string">                BEGIN(invalid_string);</span><br><span class="hljs-string">                return (ERROR);</span><br><span class="hljs-string">              &#125;</span><br><span class="hljs-string">             &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;string&gt;[^\\\n\0\&quot;]+ &#123;</span><br><span class="hljs-string">                      char *yyptr = yytext;</span><br><span class="hljs-string">                      while(*yyptr)&#123;</span><br><span class="hljs-string">                        str_len ++;</span><br><span class="hljs-string">                        CHECK_STRING_LENGTH()</span><br><span class="hljs-string"></span><br><span class="hljs-string">                        *string_buf_ptr++ = *yyptr++;</span><br><span class="hljs-string">                      &#125;</span><br><span class="hljs-string">                    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;invalid_string&gt;[^\n&quot;</span>]*(\n|\<span class="hljs-string">&quot;) BEGIN(0); /* jump to the end of the string */</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>注释分为两种，单行注释（以<code>--</code>开头）以及多行嵌套注释（以<code>(*</code>开头）。</p><p>前者较为简单，后者需要考虑嵌套的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;--&quot;</span>[^\n]* <span class="hljs-comment">/* single line comment, don&#x27;t eat up the \n*/</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *  Nested comments</span><br><span class="hljs-comment">  */</span><br><br><br>&#123;LEFTCOMMENT&#125; &#123;<br>              BEGIN(comment);<br>              comment_num =<span class="hljs-number">1</span>;<br>              &#125;<br><br>&lt;comment&gt;&#123;LEFTCOMMENT&#125; &#123;comment_num++;&#125;<br><br>&lt;comment&gt;[^(*\n]+  <span class="hljs-comment">/* eat up all the characters which are not * or newline */</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;(&quot;</span>+[^*]* <span class="hljs-comment">/* eat up all the ( which are not nested (*/</span><br><br>&lt;comment&gt;<span class="hljs-string">&quot;*&quot;</span>+[^*)\n]* <span class="hljs-comment">/* eat up all the * which are not follwed by *) or new line*/</span><br><br>&lt;comment&gt;&lt;&lt;EOF&gt;&gt; &#123;<br>            cool_yylval.error_msg = <span class="hljs-string">&quot;EOF in comment&quot;</span>;<br>            BEGIN(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> (ERROR);<br>            &#125;<br><br>&lt;comment&gt;\n ++curr_lineno;<br><br>&lt;comment&gt;&#123;RIGHTCOMMENT&#125; &#123;<br>                          comment_num--;<br>                          <span class="hljs-keyword">if</span> (comment_num ==<span class="hljs-number">0</span>)&#123;<br>                              BEGIN(<span class="hljs-number">0</span>);<br>                          &#125;<br>                        &#125;<br></code></pre></td></tr></table></figure><h5 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h5><p>注意大小写即可，此处按下不表。</p><h5 id="White-Spaces"><a href="#White-Spaces" class="headerlink" title="White Spaces"></a>White Spaces</h5><p>需要将换行符单独考虑，维护代码行数，此处按下不表。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>PA2并不困难，只是较为繁琐（例如String以及Comment中状态机的设计），实验整体耗时大约8小时。</p><p>学习到的知识点：</p><ol><li>lexer工作基本流程；</li><li>flex如何使用，一些较为进阶的小技巧。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【区间DP】Polygon</title>
    <link href="/2021/01/29/tj-211129/"/>
    <url>/2021/01/29/tj-211129/</url>
    
    <content type="html"><![CDATA[<h3 id="题面链接"><a href="#题面链接" class="headerlink" title="题面链接"></a>题面链接</h3><p><a href="https://www.acwing.com/problem/content/description/285/">https://www.acwing.com/problem/content/description/285/</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目给出一个多边形，边为运算符，顶点为数值，所求为删去一条边之后，通过不断合并边可以获得的最大值。</p><p>乍一看，删去哪一条边获取最大值是未知的，需要枚举每一条边。</p><p>枚举之后，原来的多边形退化为一条链，问题变成一个类似石子合并（<a href="https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。">https://www.acwing.com/problem/content/284/）的问题，大致方向就是区间DP，阶段更新就是区间的长度。问题变为，如何确定满足无后效性以及最优子结构性质的状态。</a></p><p>由于运算符中存在乘法，故而不能将状态设计为<strong>最大值</strong>，因为一个负的最大值和一个正的最大值的乘积可能是一个很小的值。因此，还需要设计一个<strong>最小值</strong>状态，在乘法更新的时候，需要枚举<strong>最大值、最小值</strong>相乘的四种情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NINF = <span class="hljs-number">-0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MUL = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> dp_max[N][N];<br><span class="hljs-keyword">int</span> dp_min[N][N];<br><br><span class="hljs-keyword">int</span> val[N];<br><span class="hljs-keyword">int</span> op[N];<span class="hljs-comment">// 0-add, 1-mul</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> tot)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>            dp_max[i][j]=NINF;<br>            dp_min[i][j]=INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;len&lt;=tot;len++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l+len<span class="hljs-number">-1</span>&lt;tot;l++)&#123;<br>            <span class="hljs-keyword">int</span> r = l+len<span class="hljs-number">-1</span>;<br>            <br>            <span class="hljs-keyword">int</span> _l = (l+start)%tot;<br>            <span class="hljs-keyword">if</span> (len==<span class="hljs-number">1</span>)&#123;<br>                dp_max[l][r] = val[_l];<br>                dp_min[l][r] = val[_l];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=l; k&lt;r; k++)&#123;<br>                <span class="hljs-keyword">int</span> _op = op[(k+<span class="hljs-number">1</span>+start)%tot];<br>                <span class="hljs-keyword">if</span> (_op==ADD)&#123;<br>                    dp_max[l][r] = max(dp_max[l][r], dp_max[l][k]+dp_max[k+<span class="hljs-number">1</span>][r]);<br>                    dp_min[l][r] = min(dp_min[l][r], dp_min[l][k]+dp_min[k+<span class="hljs-number">1</span>][r]);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (_op==MUL)&#123;<br>                    <span class="hljs-keyword">int</span> MM = dp_max[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> Mm = dp_max[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mM = dp_min[l][k]*dp_max[k+<span class="hljs-number">1</span>][r];<br>                    <span class="hljs-keyword">int</span> mm = dp_min[l][k]*dp_min[k+<span class="hljs-number">1</span>][r];<br>                    dp_max[l][r] = max(dp_max[l][r],max(MM,max(Mm,max(mM,mm))));<br>                    dp_min[l][r] = min(dp_min[l][r], min(MM,min(Mm,min(mM,mm))));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_max[<span class="hljs-number">0</span>][tot<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tot;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;tot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">char</span> ch;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;ch;<br>        op[i] = (ch==<span class="hljs-string">&#x27;t&#x27;</span>)?ADD:MUL;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;val[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans_set;<br>    <span class="hljs-keyword">int</span> max_val=NINF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)&#123;<br>        <span class="hljs-keyword">int</span> tem_val = solve(i,tot);<br>        <span class="hljs-keyword">if</span>(tem_val&gt;max_val)&#123;<br>            max_val = tem_val;<br>            ans_set.clear();<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem_val == max_val)&#123;<br>            ans_set.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;max_val&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans_set)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>算法</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS143 PA1 实验过程</title>
    <link href="/2021/01/28/CS143-PA1/"/>
    <url>/2021/01/28/CS143-PA1/</url>
    
    <content type="html"><![CDATA[<p>cs143在线课程的第一次PA十分简单，熟悉<code>cool</code>语言，并实现一个简单的Stack Machine。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方提供了一个unbuntu 10.05版本的上古虚拟机（真的是上古，<code>sudo apt-get update</code>都已经404了），虚拟机内提供了实验所需的环境；另一种方式是直接使用32位（如果使用64位的机器，需要自己折腾一下spim的安装）的linux虚拟机进行实验。</p><p>我采取了第二种配置方式，因为自己的32bit虚拟机上有vscode，比起vim更加人性化，阅读源码也比较方便。</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>PA1非常简单，实现以下语言的解释器：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210128203630.png" alt="stackmachine"></p><p><code>cool</code>语言没有高级数据结构，所以首先需要实现一个栈（使用<code>list</code>实现即可）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span></span>&#123;<br>   mystack : List&lt;-<span class="hljs-keyword">new</span> List;<br><br>   push(s: String): Object&#123;<br>      mystack &lt;- mystack.cons(s)<br>   &#125;;<br><br>   pop(): Object &#123;<br>      mystack &lt;- mystack.tail()<br>   &#125;;<br><br>   top(): String &#123;<br>      <span class="hljs-keyword">if</span> mystack.isNil() then<br>         <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-keyword">else</span><br>         mystack.head()<br>      fi&#125;;<br><br>   list():List&#123;mystack&#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>接着使用<code>StackMachine</code>类完成解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackMachine</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span></span>&#123;<br>   mystack: Stack&lt;-<span class="hljs-keyword">new</span> Stack;<br>   mya2i: A2I&lt;-<span class="hljs-keyword">new</span> A2I;<br>   print_list(l : List) : Object &#123;<br>      <span class="hljs-keyword">if</span> l.isNil() then <span class="hljs-number">0</span><br>                   <span class="hljs-keyword">else</span> &#123;<br>   out_string(l.head());<br>   out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>   print_list(l.tail());<br>      &#125;<br>      fi<br>   &#125;;<br><br>   readCommand(ch: String):Bool&#123;<br>      &#123;<br>         out_string(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>         out_string(ch);<br>         out_string(<span class="hljs-string">&quot;\n&quot;</span>);<br>         <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;e&quot;</span> then &#123;<br>            let stacktop:String &lt;- mystack.top() in &#123;<br>               <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;+&quot;</span> then&#123;<br>                  mystack.pop();<br>                  let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(mya2i.i2a(mya2i.a2i(v1)+mya2i.a2i(v2)));<br>                  &#125;;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  <span class="hljs-keyword">if</span> stacktop = <span class="hljs-string">&quot;s&quot;</span> then&#123;<br>                     mystack.pop();<br>                     let v1:String, v2:String in &#123;<br>                     v1&lt;-mystack.top();mystack.pop();<br>                     v2&lt;-mystack.top();mystack.pop();<br>                     mystack.push(v1);<br>                     mystack.push(v2);<br>                  &#125;;<br>                  &#125;<br>                  <span class="hljs-keyword">else</span>&#123;<br>                     <span class="hljs-number">0</span>;<br>                  &#125;<br>                  fi;<br>               &#125;<br>               fi;<br>            &#125;;<br>            <span class="hljs-keyword">true</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;d&quot;</span> then&#123;<br>               print_list(mystack.list());<br>               <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span> ch = <span class="hljs-string">&quot;x&quot;</span>then&#123;<br>                  <span class="hljs-keyword">false</span>;<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                  mystack.push(ch);<br>                  <span class="hljs-keyword">true</span>;<br>               &#125;<br>               fi;<br>            &#125;<br>            fi;<br>         &#125;<br>         fi;<br>      &#125;<br>   &#125;;<br><br>   <br>&#125;;<br></code></pre></td></tr></table></figure><p>不是特别熟悉<code>cool</code>，所以代码写的挺烂的。</p><p>最后在主函数调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-title">inherits</span> <span class="hljs-title">IO</span> </span>&#123;<br><br>   main() : Object &#123;<br>      let mystackmachine:StackMachine&lt;-<span class="hljs-keyword">new</span> StackMachine in &#123;<br>         <span class="hljs-keyword">while</span> mystackmachine.readCommand(in_string())loop<br>            <span class="hljs-number">0</span><br>         pool;<br>      &#125;<br>   &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COOL语言入门（正在更新中）</title>
    <link href="/2021/01/26/cool-01/"/>
    <url>/2021/01/26/cool-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>说明</strong></p><p>本文为笔者学习CS 143过程中，阅读Cool Manual所做笔记（基本上是内容的翻译以及简化）。</p></blockquote><h3 id="什么是cool"><a href="#什么是cool" class="headerlink" title="什么是cool"></a>什么是<code>cool</code></h3><p><code>cool</code>的全称是Classroom Object-Oriented Language，是Standford为了教学而创造的一种编程语言。CS 143 课程的Programming Assignment 就是完成<code>cool</code>语言的编译器。</p><h3 id="cool的主要特性"><a href="#cool的主要特性" class="headerlink" title="cool的主要特性"></a><code>cool</code>的主要特性</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>cool</code>使用<code>coolc</code>进行编译，编译指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/coolc [ -o fileout ] file1.cl file2.cl ... filen.cl<br></code></pre></td></tr></table></figure><p>和<code>gcc</code>语法类似，<code>-o</code>之后为输出的文件名（该项可选，默认为之后跟着的第一个文件名+<code>.s</code>）；<code>file1.cl, file2.cl</code>为需要编译的源程序文件名（<code>cool</code>的文件后缀为<code>.cl</code>）。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>coolc</code>输出的是MIPS汇编指令，可以通过<code>spim</code>运行（<code>spim</code>实际上就是MIPS倒过来）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim<br>(spim) load <span class="hljs-string">&quot;file.s&quot;</span><br>(spim) run<br></code></pre></td></tr></table></figure><p>一般使用如下语句直接进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ [cool root]/bin/spim -file file.s<br></code></pre></td></tr></table></figure><h4 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h4><h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p><code>cool</code>中的所有代码都组织成类。每一个类的所有内容必须被包括在一个源文件中，一个源文件可以包括多个类。</p><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class &lt;type&gt; [ inherits &lt;type&gt; ] &#123;<br>&lt;feature_list&gt;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所有的类名（type）都是全局可见的，需要以大写字母开头；类名不可以重复。</p><h6 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h6><p>在<code>cool</code>中，属性（成员变量）以及方法（method）被称作feature。</p><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p><code>cool</code>支持继承机制，并且只支持单继承。与<code>Java</code>类似，如果一个类没有显式声明的一个类，那么其默认继承<code>Object</code>。</p><h5 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h5><p><code>cool</code>语言中提供了类型机制，支持在编译时进行类型检查。</p><h6 id="self-type"><a href="#self-type" class="headerlink" title="self type"></a>self type</h6><p>self type 用于class，其类型不固定。根据上下文决定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【折腾】脱胎换骨的 断桨</title>
    <link href="/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/"/>
    <url>/2021/01/25/%E6%8D%A3%E9%BC%93%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用hexo建站"><a href="#为什么使用hexo建站" class="headerlink" title="为什么使用hexo建站"></a>为什么使用hexo建站</h3><p>之前使用namesilo购买过一个域名，使用aliyun配合Wordpress建立了一个小站：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125224831.png" alt="Wordpress建站"></p><p>emmm……看起来有一点朴素。使用Wordpress的过程中，我主要感受到了以下的几个问题：</p><ol><li>配置不自由。自带的主题过少，一些高质量的主题需要氪金（不过也没有什么特别喜欢的风格）；</li><li>服务器配置过低。这是我自身的原因，我在aliyun上租的是一个一核的服务器，实在是不太行，每一次访问站点的时候都卡的不行，服务器还崩过几次（明明没有人访问啊！）；</li><li>写作必须要在线环境。似乎没有找到什么本地写作，然后远程自动更新的方式（可能还是我太菜了），每一次想要写作的时候，都要在Wordpress 的后台上写，实在是不方便啊！</li><li>要备案。我是一条懒狗，到现在还没有备案（苦笑）。</li></ol><p>相比之下，我通过hexo + GithubPages配置的过程就十分轻松了：</p><ol><li>hexo 本身只需要一些简单的配置（node.js之类，也就是命令行随便敲一敲）；</li><li>GithubPages更是一步解决了服务器以及备案的问题（国外的服务器，不需要备案了）；</li><li>hexo 支持本地编辑。hexo 目前使用下来就是本地写作,然后<code>hexo g&amp;hexo d</code>素质三连，十分符合我的写作习惯；</li><li>定制化空间高。比如我现在使用的主体就来自一个开源的项目，颜值在线。</li></ol><h3 id="新的断桨，将会包含哪些内容？"><a href="#新的断桨，将会包含哪些内容？" class="headerlink" title="新的断桨，将会包含哪些内容？"></a>新的断桨，将会包含哪些内容？</h3><blockquote><p> 博客只是一个载体，重要的是内部承载的内容。</p></blockquote><p>目前的想法是，连载自己的<strong>课程笔记、读书笔记、项目介绍</strong>等专业性比较强的内容的同时，也加入一些诸如<strong>漫评、影评</strong>的娱乐性内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lexier</title>
    <link href="/2021/01/25/Lexer/"/>
    <url>/2021/01/25/Lexer/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Lexcial-Analyzer"><a href="#什么是Lexcial-Analyzer" class="headerlink" title="什么是Lexcial Analyzer"></a>什么是Lexcial Analyzer</h3><p>我们知道，编译器的输入是源程序(source program)，然而，编译器无法直接<strong>理解</strong>程序中的<strong>字符串</strong>（尽管他们是结构化的语言），需要进行进一步的结构化。</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125222819.png" alt="image-20210125222819890"></p>]]></content>
    
    
    
    <tags>
      
      <tag>compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好！过客</title>
    <link href="/2021/01/25/NewBegin/"/>
    <url>/2021/01/25/NewBegin/</url>
    
    <content type="html"><![CDATA[<p>你是现在世界上少数几个知道本网站存在的人之一，恭喜你，幸运儿！</p><p>以下是对博客框架<code>hexo</code>以及博客主题<code>Fluid</code>的一些简单测试，并没有什么具体的含义。</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><script type="math/tex; mode=display">L_o(p,w_o) = L_e(p, w_o) + \int_{\Omega^+}L_i(p,w_i)f_r(p, w_i,w_o)cos\theta\ d\omega</script><h3 id="Path-Tracing伪代码"><a href="#Path-Tracing伪代码" class="headerlink" title="Path Tracing伪代码"></a><code>Path Tracing</code>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shade (p, w_o):<br>blabla<br>......<br>    <span class="hljs-keyword">return</span> L_dir + L_indir<br></code></pre></td></tr></table></figure><h3 id="寒假计划"><a href="#寒假计划" class="headerlink" title="寒假计划"></a>寒假计划</h3><ol><li>吃</li><li>喝</li><li>睡</li></ol><h4 id="来一些图表"><a href="#来一些图表" class="headerlink" title="来一些图表"></a>来一些图表</h4><p>测试图床：</p><p><img src="https://cdn.jsdelivr.net/gh/Mellorsssss/PictureBed/img/20210125223350.png" alt="image-20210125223350250"></p><p>测试表格：</p><div class="table-container"><table><thead><tr><th>id</th><th>名称</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>皮卡丘</td><td>电系</td></tr><tr><td>2</td><td>喷火龙</td><td>火，飞行</td></tr><tr><td>3</td><td>迪奥西斯</td><td>超能</td></tr></tbody></table></div><h3 id="测试各种简单的语法"><a href="#测试各种简单的语法" class="headerlink" title="测试各种简单的语法"></a>测试各种简单的语法</h3><p><strong>如果让你重新来过，你会不会爱我</strong></p><blockquote><p>爱情让人拥有快乐，也会带来折磨</p></blockquote><p>We used to be lovers.</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
